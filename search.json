[{"title":"hexo使用rsync部署填坑之路","url":"/2021/11/21/hexo%E4%BD%BF%E7%94%A8rsync%E9%83%A8%E7%BD%B2%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/","content":"hexo 可快速上手做出自己的博客网站，部署方式 也非常多。在部署到github的时候基本不会遇到什么问题，但是当选择使用rsync部署到阿里云ECS的时候，windows下部署的坑就一个个的出现了。\n遇到的问题首先看下官方的部署教程， 只有下面一小段内容：\n安装 hexo-deployer-rsync。\n$ npm install hexo-deployer-rsync --save\n修改配置\ndeploy:  type: rsync  host: &lt;host&gt;  user: &lt;user&gt;  root: &lt;root&gt;  port: [port]  delete: [true|false]  verbose: [true|false]  ignore_errors: [true|false]\nrsync不存在的报错直接运行 hexo d 之后就会报错了，有可能在powershell上面是乱码，git bash运行后出现以下报错：\nINFO  Validating configINFO  Deploying: rsync&#x27;rsync&#x27; is not recognized as an internal or external command,operable program or batch file.\n\nwindows默认没安装rsync，查找之后要安装cwrsync。然后去官网下载多个版本后出现了各种其他问题，这里我用5.5.0版本完成了后续操作。\n下载之后进行了如下操作：\n首先，下载的软件包解压到想放的位置，然后双击 cwrsync.cmd 开始安装，正常则会生成 home 目录，但是我这边没有生成(截图中是我后手动添加的)。\n\nok，先没管 home 目录，先将 bin 目录添加到环境变量，以便访问到 rsync.exe 文件。之后再来 hexo d 一次。好，出现了如下报错：\nINFO  Validating configINFO  Deploying: rsyncCould not create directory &#x27;/home/lazy5/.ssh&#x27;.Host key verification failed.rsync: connection unexpectedly closed (0 bytes received so far) [sender]rsync error: error in rsync protocol data stream (code 12) at io.c(226) [sender=3.1.2]\n\n上面报错那意思没找到ssh密钥存储的目录，奇怪的是我这边用户根目录下有.ssh目录，且服务器上也添加了对应公钥。而且这个目录很奇怪，/home这种目录应该指的linux下的目录结构吧。几番研究发现，这个版本的rsync调用的ssh并不是我们安装的，而是cwrsync的bin目录下的ssh.exe，那意思就是这个密钥目录可能不是指向用户目录的，而是cwrsync的安装目录。于是，在安装目录我新建了 /home/lazy5/.ssh 目录。\n同时双击 bin 目录下的 ssh-keygen.exe 文件，之后一路回车，则在 /home/lazy5/.ssh 目录下生成密钥对，目录如下：\n\n将生成的公钥添加到服务器对应用户的 authorized_keys 中，然后再部署一次试试。还是失败了，查看下面的 无权限报错\n无权限报错首先出现的是如下权限过高的问题：\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0770 for &#x27;/home/lazy5/.ssh/id_rsa&#x27; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;/home/lazy5/.ssh/id_rsa&quot;: bad permissionsPermission denied (publickey,gssapi-keyex,gssapi-with-mic).\n\n因此，我删除了 /home/lazy5/.ssh/id_rsa 除了所有者 lazy5 以外的权限。\n以上设置之后，权限过高的问题就没有了。理论上这样部署就没有了，但是在实际操作中还遇到了其他权限问题，具体截图没有了，列举如下：\n\ndeploy 配置使用的是 root ，导致访问被拒绝。这里建议新建一个用户用户rsync的操作，同时建议和本地windows电脑用户名一致，我这里是 lazy5，服务器上也新建了一个一样的用户名。\n部署报建立文件夹没权限的问题：由于新建的 lazy5 不在 root 组，而部署的目录属于 root 用户，chown 将目录权限改到 lazy5， 同时也可以把 lazy5 加到 root 组。\n服务器访问拒绝的其他权限问题：服务器ssh未开启公钥登录的方式，修改配置文件。\nvim /etc/ssh/sshd_config\n增加如下配置： PubkeyAuthentication yesPermitRootLogin yesPasswordAuthentication noRSAAuthentication yes\n重新加载，systemctl restart sshd\n\n\n\n成功上传之后域名访问403一切大功告成，访问网站出现了403，估计是权限的问题了。查看hexo目录下的文件权限如下：\nchmod 777 hexo -R 之后可以正常访问，但是每次部署后都需要登录服务器修改权限，这种方式肯定是不行的。那rsync为什么要改权限呢，依据是什么？前面说到了部署到服务器的文件是lazy5权限，那是不是文件访问的权限是不是也是直接用了本地文件权限。\n查看本地项目目录属性，权限中没有 Everyone，因此添加上去再说。\n重新部署后，终于权限正常了！\n后语以上就是 hexo 中使用 rsync 遇到坑的大致记录，其中由于填坑过程遗漏了很多记录，所以不一定全面，后续有再遇到会继续补充。另外由于坑太多，感觉这里直接 pm2 部署，在服务器上再 hexo generate 生成，估计也能达到一样的效果，后续可尝试并记录下。\n","categories":["服务器"],"tags":["hexo","ssh","部署"]},{"title":"shell学习记录","url":"/2022/05/11/shell%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"shell 常用于服务器上编译部署脚本、文件归档等场景。此文记录常用的语法，方便后续使用查找。\n变量常用系统变量$HOME、 $PWD、 $SHELL、 $USER 等 \n特殊变量\n$n\n\nn 为数字， $0 代表该脚本名称， $1-$9 代表第一到第九个参数， 十以上的参数， 十以上的参数需要用大括号包含， 如${10} \n\n$#\n\n获取所有输入参数个数， 常用于循环,判断参数的个数是否正确以及加强脚本的健壮性 \n\n$*、 $@代表命令行中所有的参数，$*把所有的参数看成一个整体 ，$@把每个参数区分对待\n$?\n\n最后一次执行的命令的返回状态。 如果这个变量的值为 0， 证明上一个命令正确执行； 如果这个变量的值为非 0（具体是哪个数， 由命令自己来决定） ， 则证明上一个命令执行不正确 \n字符串处理\n获取字符串长度\n\n$&#123;#string&#125;  获取字符串string的长度$&#123;string:1:4&#125;  截取字符串，从第2个字符开始，截取长度为4\n\n查找字符串\n\n查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)\nstring=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io`  # 输出 4\n数组数组的定义用小括号包裹，数组的值之间用空格区隔\narray_name=(value0 value1 value2 value3)# 单独定义也可以array_name[0]=value0array_name[1]=value1array_name[n]=valuen\n数组的读取$&#123;array_name[n]&#125; 获取数组的某一项$&#123;array_name[@]&#125; 获取数组所有参数$&#123;#array_name[@]&#125;、$&#123;#array_name[*]&#125; 获取数组元素的个数\n运算符$((运算式))  或  $[运算式] \n关系运算符\n\n\n-eq\n检测两个数是否相等，相等返回 true。\n\n\n\n-ne\n检测两个数是否不相等，不相等返回 true。\n\n\n-gt\n检测左边的数是否大于右边的，如果是，则返回 true。\n\n\n-lt\n检测左边的数是否小于右边的，如果是，则返回 true。\n\n\n-ge\n检测左边的数是否大于等于右边的，如果是，则返回 true。\n\n\n-le\n检测左边的数是否小于等于右边的，如果是，则返回 true。\n\n\n布尔运算符\n\n\n!\n非运算，表达式为 true 则返回 false，否则返回 true。\n\n\n\n-o\n或运算，有一个表达式为 true 则返回 true。\n\n\n-a\n与运算，两个表达式都为 true 才返回 true。\n\n\n逻辑运算符\n\n\n&amp;&amp;\n逻辑的 AND\n\n\n\n&#124;&#124;\n逻辑的 OR\n\n\n字符串运算符\n\n\n=\n检测两个字符串是否相等，相等返回 true。\n\n\n\n!=\n检测两个字符串是否不相等，不相等返回 true。\n\n\n-z\n检测字符串长度是否为0，为0返回 true。\n\n\n-n\n检测字符串长度是否不为 0，不为 0 返回 true。\n\n\n$\n检测字符串是否为空，不为空返回 true。\n\n\n文件测试运算符\n\n\n-b file\n检测文件是否是块设备文件，如果是，则返回 true。\n\n\n\n-c file\n检测文件是否是字符设备文件，如果是，则返回 true。\n\n\n-d file\n检测文件是否是目录，如果是，则返回 true。\n\n\n-f file\n检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。\n\n\n-g file\n检测文件是否设置了 SGID 位，如果是，则返回 true。\n\n\n-k file\n检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。\n\n\n-p file\n检测文件是否是有名管道，如果是，则返回 true。\n\n\n-u file\n检测文件是否设置了 SUID 位，如果是，则返回 true。\n\n\n-r file\n检测文件是否可读，如果是，则返回 true。\n\n\n-w file\n检测文件是否可写，如果是，则返回 true。\n\n\n-x file\n检测文件是否可执行，如果是，则返回 true。\n\n\n-s file\n检测文件是否为空（文件大小是否大于0），不为空返回 true。\n\n\n-e file\n检测文件（包括目录）是否存在，如果是，则返回 true。\n\n\n流程控制if判断基本语法\n# 单分支if [ 条件判断式 ];then  程序fiif [ 条件判断式 ]then  程序fi# 多分支if [ 条件判断式 ]then  程序elif [ 条件判断式 ]then  程序else  程序fi\n举个栗子\n#!/bin/bashif [ $1 -eq 1 ]then  echo &quot;banzhang zhen shuai&quot;elif [ $1 -eq 2 ]then  echo &quot;cls zhen mei&quot;fi\ncase语法基本语法\ncase $变量名 in&quot;值 1&quot;）  如果变量的值等于值 1， 则执行程序 1;;&quot;值 2&quot;）  如果变量的值等于值 2， 则执行程序 2;;  …省略其他分支…*）  如果变量的值都不是以上的值， 则执行此程序;;esac\n注意事项：（1） case 行尾必须为单词“in” ， 每一个模式匹配必须以右括号“） ” 结束。（2） 双分号“;;” 表示命令序列结束， 相当于 java 中的 break。（3） 最后的“*） ” 表示默认模式， 相当于 java 中的 default。 \nfor循环基本语法\nfor (( 初始值;循环控制条件;变量变化 ))do  程序done\n举个栗子\n#!/bin/bashsum=0for((i=0;i&lt;=100;i++))do  sum=$[$sum+$i]doneecho $sum\nfor…in语法\nfor 变量 in 值 1 值 2 值 3…do  程序done\n举个栗子\n#!/bin/bash#打印数字for i in cls mly wlsdo  echo &quot;ban zhang love $i&quot;done\nwhile循环基本语法\nwhile [ 条件判断式 ]do  程序done\n举个栗子\n#!/bin/bashsum=0i=1while [ $i -le 100 ]do  sum=$[$sum+$i]  i=$[$i+1]doneecho $sum\n读取控制台输入\n基本语法\n\nread (选项) (参数)①选项：-p： 指定读取值时的提示符；-t： 指定读取值时等待的时间（秒） 如果-t 不加表示一直等待②参数变量： 指定读取值的变量名 \n\n举个栗子#!/bin/bashread -t 7 -p &quot;Enter your name in 7 seconds :&quot; NNecho $NN\n\n函数系统函数basename\n基本语法\n\nbasename [string / pathname] [suffix] （ 功能描述： basename 命令会删掉所有的前缀包括最后一个（‘/’） 字符， 然后将字符串显示出来。    basename 可以理解为取路径里的文件名称    选项：    suffix 为后缀， 如果 suffix 被指定了， basename 会将 pathname 或 string 中的 suffix 去掉 \n\n举个栗子\n# 以下可以取出banzhangbasename /home/lazy5/banzhang.txt .txt\ndirname\n基本语法\n\n\ndirname 文件绝对路径 （功能描述： 从给定的包含绝对路径的文件名中去除文件名（非目录的部分） ， 然后返回剩下的路径（目录的部分） ）    dirname 可以理解为取文件路径的绝对路径名称 \n\n举个栗子\n# /home/lazy5dirname /home/lazy5/banzhang.txt\n自定义函数\n基本语法\n[ function ] funname[()]&#123;  Action;  [return int;]&#125;\n说明\n\n\n（1） 必须在调用函数地方之前， 先声明函数， shell 脚本是逐行运行。 不会像其它语言一样先编译。（2） 函数返回值， 只能通过$?系统变量获得， 可以显示加： return 返回， 如果不加， 将以最后一条命令运行结果， 作为返回值。 return 后跟数值 n(0-255) \n\n举个栗子\n#!/bin/bashfunction sum()&#123;  s=0  s=$[$1+$2]  echo &quot;$s&quot;&#125;read -p &quot;Please input the number1: &quot; n1;read -p &quot;Please input the number2: &quot; n2;sum $n1 $n2;\n文件包含\n基本语法\n. filename   # 注意点号(.)和文件名中间有一空格或source filename\n举个栗子\n\n\ntest1.sh 代码如下：\n#!/bin/bashurl=&quot;http://www.starsea.club&quot;\ntest2.sh 代码如下：\n#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho &quot;我的地址：$url&quot;\n\n输入/输出重定向\n\n\n命令\n说明\n\n\n\ncommand &gt; file\n将输出重定向到 file。\n\n\ncommand &lt; file\n将输入重定向到 file。\n\n\ncommand &gt;&gt; file\n将输出以追加的方式重定向到 file。\n\n\nn &gt; file\n将文件描述符为 n 的文件重定向到 file。\n\n\nn &gt;&gt; file\n将文件描述符为 n 的文件以追加的方式重定向到 file。\n\n\nn &gt;&amp; m\n将输出文件 m 和 n 合并。\n\n\nn &lt;&amp; m\n将输入文件 m 和 n 合并。\n\n\n&lt;&lt; tag\n将开始标记 tag 和结束标记 tag 之间的内容作为输入。\n\n\n\n需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）\n\n输出重定向\n基本语法\ncommand1 &gt; file1\n举个栗子\n# 将who命令的结果输出到文件userswho &gt; users# 替换users的内容echo &quot;替换内容&quot; &gt; users# 追加内容到usersecho &quot;追加内容&quot; &gt;&gt; users\n\n输入重定向\n基本语法\ncommand1 &lt; file1\n举个栗子\n# 会输出2 users，行数+文件名wc -l users# 此处直接输出2，只显示行数，因为wc只知道是从标准输入读取的内容wc -l &lt; users\n\n同时输出/输入command1 &lt; infile &gt; outfile\ncommand1 &lt; infile &gt; outfile\n重定向深入讲解一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n\n标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。\n标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。\n标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。\n\n默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。如果希望 stderr 重定向到 file，可以这样写：\ncommand 2&gt;file# stderr追加command 2&gt;&gt;file\n如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：\ncommand &gt; file 2&gt;&amp;1或者command &gt;&gt; file 2&gt;&amp;1\n如果希望对 stdin 和 stdout 都重定向，可以这样写：\ncommand &lt; file1 &gt;file2\n\n/dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：\ncommand &gt; /dev/null\n如果希望屏蔽 stdout 和 stderr，可以这样写：\ncommand &gt; /dev/null 2&gt;&amp;1\n","categories":["服务器"],"tags":["shell","sh","bash"]},{"title":"vue-virtual-scroller源码分析","url":"/2021/11/20/vue-virtual-scroller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"该插件目的当页面数据量较大，例如有几千条数据渲染的时候，dom过多产生滚动卡顿的现象。此时使用该插件可以动态渲染可视区的dom，滚动时实时计算和变更可视区显示的数据。\n原理根据可视区的高度以及items中每一项的高度(itemSize，可为高度或者是横向滑动的宽度)来决定页面展示多少个item，能显示的item包装后放到了pool数组中进行渲染，页面滚动的时候动态的修改pool数组。为了在滚动的时候尽可能的减少开销，pool中超出范围的view会回收到复用池，pool中新增的view会优先从复用池中取出view，如果没有复用的才会新增。\n页面中数据流动为了达到动态渲染和dom复用的目的，主要维护了一下三个存放对应item的池子。\n\npool：当前页面显示得视图池，存储当前页面要渲染得数据，即pool是tempalte中渲染真实使用到的。&lt;div    v-for=&quot;view of pool&quot;    :key=&quot;view.nr.id&quot;    :style=&quot;ready ? &#123; transform: `translate$&#123;direction === &#x27;vertical&#x27; ? &#x27;Y&#x27; : &#x27;X&#x27;&#125;($&#123;view.position&#125;px)` &#125; : null&quot;    class=&quot;vue-recycle-scroller__item-view&quot;    :class=&quot;&#123; hover: hoverKey === view.nr.key &#125;&quot;    @mouseenter=&quot;hoverKey = view.nr.key&quot;    @mouseleave=&quot;hoverKey = null&quot;&gt;\n$_views: 和pool对应，每一次addView新增一个视图得时候，除了要把视图放到pool中，还要放一份到views中。只是views是map，数据字典方便查找view，当页面滚动得时候，会取范围在startIndex和endIndex之间得view，每个view先去views中找，这样比在pool中遍历效率要高，如果找到了说明当前view一直在可视区内，这个时候直接显示复用views中得即可。如果在views中没找到，说明是新增得view，则先去复用池中根据type找，找到则复用，找不到则addView新增，新增之后views中也要加进去。\n$_unusedViews: 复用池，根据type存储不在可视区的视图。每次滚动先把超出可视区的丢到unusedViews，丢完之后。进行startIndex和endIndex之间的可视区遍历，在新增view出现的时候优先在unusedViews中找，找到就取出来。找不到则走addView\n\n\n以下是初始化的时候对数据的初始化\n\ncreated () &#123;    // 记录刷新完成的开始索引    this.$_startIndex = 0    // 记录刷新完成的结束索引    this.$_endIndex = 0    // 页面上所有展示的视图，与pool对应，方便快速查找    this.$_views = new Map()    // 复用池：根据视图的type暂存不在使用的view    this.$_unusedViews = new Map()    // 标记是否正在滚动，用于滚动节流    this.$_scrollDirty = false    // 记录上一次滚到了哪里start值    this.$_lastUpdateScrollPosition = 0    // In SSR mode, we also prerender the same number of item for the first render    // to avoir mismatch between server and client templates    if (this.prerender) &#123;      this.$_prerender = true      this.updateVisibleItems(false)    &#125;&#125;,\n\n原理整个插件最主要的原理集中在updateVisibleItems(视图刷新函数)，该函数会在初始化、页面滚动、页面resize等情况下触发。总共的过程分为以下四步：\n\n计算可视范围：获取scroll信息后，先算出此次需要展现到可视区的items索引范围，即startIndex和endIndex。\n\n获取当前展示部分的start、end值, 并判断是否进行了足够的滚动。滚动较小则可视区展示的items不变动，不需要刷新。// 获取当前可视区的范围，getScroll根据scrollerTop等计算const scroll = this.getScroll()// Skip update if use hasn&#x27;t scrolled enough    if (checkPositionDiff) &#123;      // 此处判断当前滚动的范围未超出设置的itemSize，即没有超过一个view，此时pool不需要改变，则此次不进行update操作      let positionDiff = scroll.start - this.$_lastUpdateScrollPosition      if (positionDiff &lt; 0) positionDiff = -positionDiff      if ((itemSize === null &amp;&amp; positionDiff &lt; minItemSize) || positionDiff &lt; itemSize) &#123;        return &#123;          continuous: true,        &#125;      &#125;    &#125;    // 刷新此次滚动后的位置信息    this.$_lastUpdateScrollPosition = scroll.start    // 计算偏移量，默认buffer为200，可自定义    const buffer = this.buffer    scroll.start -= buffer    scroll.end += buffer    // Variable size mode    // 高度可变模式    // 因为每个item的高度不固定，无法直接用scroll.start得到startIndex。所以通过二分法快速查找到第一个出现在可视区的视图，即startIndex。    // 由于计算属性已缓存了可变高度的所有size记录，二分法查找的目的等价于查找到sizes中的索引，该索引满足index项的accumulator小于scroll.start，index+1项的accumulator大于scroll.start，则为刚滑到可视区的startIndex    if (itemSize === null) &#123;      let h      let a = 0      let b = count - 1      // 此处记录二分查找起始点      let i = ~~(count / 2)      let oldI      // Searching for startIndex      do &#123;        oldI = i        h = sizes[i].accumulator        if (h &lt; scroll.start) &#123;          // 说明此次i取小了，则最小值设置为i          a = i        &#125; else if (i &lt; count - 1 &amp;&amp; sizes[i + 1].accumulator &gt; scroll.start) &#123;          // 说明i、i+1都超出了范围，则最大值设置为i，继续查找          b = i        &#125;        // 继续二分        i = ~~((a + b) / 2)      &#125; while (i !== oldI)      i &lt; 0 &amp;&amp; (i = 0)      startIndex = i      // For container style      totalSize = sizes[count - 1].accumulator      // Searching for endIndex      // 找到刚好超出的endIndex      for (endIndex = i; endIndex &lt; count &amp;&amp; sizes[endIndex].accumulator &lt; scroll.end; endIndex++);      if (endIndex === -1) &#123;        endIndex = items.length - 1      &#125; else &#123;        endIndex++        // Bounds        endIndex &gt; count &amp;&amp; (endIndex = count)      &#125;    &#125; else &#123;      // Fixed size mode      // 固定高度：根据滚动的距离计算固定itemSize的startIndex和endIndex      startIndex = ~~(scroll.start / itemSize)      endIndex = Math.ceil(scroll.end / itemSize)      // Bounds      startIndex &lt; 0 &amp;&amp; (startIndex = 0)      endIndex &gt; count &amp;&amp; (endIndex = count)      totalSize = count * itemSize    &#125;  &#125;  if (endIndex - startIndex &gt; config.itemsLimit) &#123;    this.itemsLimitError()  &#125;  // 刷新items的总高度, totalSize会给到外层盒子的高度，为了制造出滚动条  this.totalSize = totalSize\n对于可变高度，计算属性会优先维护一个sizes表，已记录对应索引的size累计值。此操作目的是为了后续根据索引即可拿到size之和，而不必每次都重新计算。sizes () &#123;  // itemSize不提供，则进入variable size mode  if (this.itemSize === null) &#123;    const sizes = &#123;      &#x27;-1&#x27;: &#123; accumulator: 0 &#125;,    &#125;    const items = this.items    const field = this.sizeField    const minItemSize = this.minItemSize    let computedMinSize = 10000    let accumulator = 0    let current    for (let i = 0, l = items.length; i &lt; l; i++) &#123;      current = items[i][field] || minItemSize      if (current &lt; computedMinSize) &#123;        computedMinSize = current      &#125;      accumulator += current      sizes[i] = &#123; accumulator, size: current &#125;    &#125;    // eslint-disable-next-line    this.$_computedMinItemSize = computedMinSize    return sizes  &#125;  return []&#125;\n\n\n视图回收：遍历pool中视图，判断view的索引超出startIndex、endIndex范围，则走到unuseView函数进行视图回收，放到复用池unusedViews。(此时放到复用池只是放的引用，仍指向pool中对应的元素，不会改变pool元素个数，只改对应元素的属性\n\n\nif (this.$_continuous !== continuous) &#123;    if (continuous) &#123;        // 不是连续滑动，则页面出现了大的改变，初始化数据        views.clear()        unusedViews.clear()        for (let i = 0, l = pool.length; i &lt; l; i++) &#123;            // 将当前显示的view回收            view = pool[i]            this.unuseView(view)        &#125;    &#125;    this.$_continuous = continuous&#125; else if (continuous) &#123;    // 此时为连续滑动，遍历回收pool    for (let i = 0, l = pool.length; i &lt; l; i++) &#123;        view = pool[i]        if (view.nr.used) &#123;            // Update view item index            if (checkItem) &#123;                view.nr.index = items.findIndex(                item =&gt; keyField ? item[keyField] === view.item[keyField] : item === view.item,                )            &#125;            // Check if index is still in visible range            // 此处判断如果，index已经超出范围，则进行回收            if (                view.nr.index === -1 ||                view.nr.index &lt; startIndex ||                view.nr.index &gt;= endIndex            ) &#123;                this.unuseView(view)            &#125;        &#125;    &#125;&#125;\n\n以下为unuseView的实现：\nunuseView (view, fake = false) &#123;    // 根据view的类别放到缓存池    const unusedViews = this.$_unusedViews    const type = view.nr.type    // 根据type类别进行存放，后续复用也是根据type去取    let unusedPool = unusedViews.get(type)    if (!unusedPool) &#123;        unusedPool = []        unusedViews.set(type, unusedPool)    &#125;    unusedPool.push(view)    if (!fake) &#123;        // 此时将视图回收设置位置（让view不可见），且used置为false        view.nr.used = false        view.position = -9999        this.$_views.delete(view.nr.key)    &#125;&#125;\n\n\n更新视图：在startIndex和endIndex之间遍历，每次拿到items中的一个item，开始包装item后刷到pool中。\n根据item取views字典中查找，如果找到了，则当前view还在可视区，只是滚动了，则直接复用view即可。\n在views中未找到，则去unusedViews中找有没有可复用的view，有则使用复用视图，修改view的item、key、index等属性后即可。且后面重新设置views中对应字典，方便后面查找。\n如果unusedViews中未找到，则无复用view。此时调用addView新增视图，view增加item属性关联到items、position属性后面用于transform样式、增加used、key、id、index等标识。新增视图push到pool中，同时在views中增加字典。\n\n\n\nlet item, type, unusedPoollet v// 在可视区范围内遍历for (let i = startIndex; i &lt; endIndex; i++) &#123;  item = items[i]  const key = keyField ? item[keyField] : item  if (key == null) &#123;    throw new Error(`Key is $&#123;key&#125; on item (keyField is &#x27;$&#123;keyField&#125;&#x27;)`)  &#125;  // 3.1 根据item取views字典中查找，如果找到了，则当前view还在可视区，只是滚动了，则直接复用view即可。  view = views.get(key)  // 此处size不存在，则高度不存在，则不加到pool，因为显示不出来  if (!itemSize &amp;&amp; !sizes[i].size) &#123;    if (view) this.unuseView(view)    continue  &#125;  // No view assigned to item  // 3.2 在views中未找到，则去unusedViews中找有没有可复用的view，有则使用复用视图，修改view的item、key、index等属性后即可。且后面重新设置views中对应字典，方便后面查找。  if (!view) &#123;    type = item[typeField]    unusedPool = unusedViews.get(type)    if (continuous) &#123;      // Reuse existing view      // 根据类型找出复用池中可用的的视图，修改索引等进行复用      if (unusedPool &amp;&amp; unusedPool.length) &#123;        view = unusedPool.pop()        view.item = item        view.nr.used = true        view.nr.index = i        view.nr.key = key        view.nr.type = type      &#125; else &#123;        // 复用池中不存在则新增        // 3.3 如果unusedViews中未找到，则无复用view。此时调用addView新增视图，view增加item属性关联到items、position属性后面用于transform样式、增加used、key、id、index等标识。新增视图push到pool中，同时在views中增加字典。        view = this.addView(pool, i, item, key, type)      &#125;    &#125; else &#123;      // Use existing view      // We don&#x27;t care if they are already used      // because we are not in continous scrolling      // 因为不是连续滑动，无交叉，不用考虑使用占用的问题，直接从对应复用池中的第一个开始找      v = unusedIndex.get(type) || 0      if (!unusedPool || v &gt;= unusedPool.length) &#123;        view = this.addView(pool, i, item, key, type)        this.unuseView(view, true)        unusedPool = unusedViews.get(type)      &#125;      view = unusedPool[v]      view.item = item      view.nr.used = true      view.nr.index = i      view.nr.key = key      view.nr.type = type      unusedIndex.set(type, v + 1)      v++    &#125;    // 放到views池中，此处对应字典，方便后续查找    views.set(key, view)  &#125; else &#123;    // 当前视图中已经存在，则直接重新used即可    view.nr.used = true    view.item = item  &#125;  // Update position  // 刷新视图位置  if (itemSize === null) &#123;    view.position = sizes[i - 1].accumulator  &#125; else &#123;    view.position = i * itemSize  &#125;&#125;// 记录本地的索引this.$_startIndex = startIndexthis.$_endIndex = endIndex\n\n以下是addView的逻辑，复用池没有的时候走到addView新增视图：\naddView (pool, index, item, key, type) &#123;const view = &#123;  item,  position: 0,&#125;const nonReactive = &#123;  id: uid++,  // 此处的index对应传进来的源数据中的索引，方便后续视图复用后重新排序  index,  used: true,  key,  type,&#125;Object.defineProperty(view, &#x27;nr&#x27;, &#123;  configurable: false,  value: nonReactive,&#125;)// 新增视图放到pool当中pool.push(view)return view&#125;\n\n\n\n排序视图：以上处理完成之后pool可能是无序的，因为存在复用池复用等情况，因此要进行排序，调用sortViews方法会根据pool中视图存的index值进行重排。\n\nclearTimeout(this.$_sortTimer)this.$_sortTimer = setTimeout(this.sortViews, 300)// sortViews的实现sortViews () &#123;  this.pool.sort((viewA, viewB) =&gt; viewA.nr.index - viewB.nr.index)&#125;\n\n结语该插件中pool、$_unusedViews、$_views三者对应的处理是很值得学习的。$_unusedViews的使用使得不比每次都去删减pool的数据达到渲染的目的，反观自己平时的开发，类似滚动、轮播等处理的方式，大概率直接截取源数据的某一范围给到pool达到刷新目的，效果是实现，但是有优化的空间。$_views的使用、以及计算属性sizes的使用均是为了降低复杂度，对于我们动不动就遍历、findIndex等处理，这种预先存储进map、或者预先存储累加值的做法更为优雅，同时也大大的降低了复杂度，减少在每次刷新视图中的遍历逻辑。\n","categories":["前端"],"tags":["Vue"]},{"title":"svg学习记录","url":"/2022/05/13/svg-study/","content":"常用形状矩形&lt;rect x=&quot;60&quot; y=&quot;10&quot; rx=&quot;10&quot; ry=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nx\n矩形左上角的x位置\n\n\ny\n矩形左上角的y位置\n\n\nwidth\n矩形的宽度\n\n\nheight\n矩形的高度\n\n\nrx\n圆角的x方位的半径\n\n\nry\n圆角的y方位的半径\n\n\n圆形&lt;circle cx=&quot;25&quot; cy=&quot;75&quot; r=&quot;20&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nr\n圆的半径\n\n\ncx\n圆心的x位置\n\n\ncy\n圆心的y位置\n\n\n椭圆&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nrx\n椭圆的x半径\n\n\nry\n椭圆的y半径\n\n\ncx\n椭圆中心的x位置\n\n\ncy\n椭圆中心的y位置\n\n\n线条&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nx1\n起点的x位置\n\n\ny1\n起点的y位置\n\n\nx2\n终点的x位置\n\n\ny2\n终点的y位置\n\n\n折线&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot;/&gt;\npoints点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。\n多边形&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot;/&gt;\npoints点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。\n路径&lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;\n参数含义：\n\nM = moveto\nL = lineto\nH = horizontal lineto\nV = vertical lineto\nC = curveto\nS = smooth curveto\nQ = quadratic Bézier curve\nT = smooth quadratic Bézier curveto\nA = elliptical Arc\nZ = closepath\n以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。\n\n\n\n贝塞尔曲线\n三次贝塞尔曲线\n// 语法C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)// 举例&lt;path d=&quot;M70 10 C 70 20, 120 20, 120 10&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点\n\n三次贝塞尔曲线简化\n\n\n一般情况下，三次贝塞尔曲线的两个控制点对称，因此可以简化只写一个控制点。语法如下：\nS x2 y2, x y (or s dx2 dy2, dx dy)\n当S命令之前是C或者S命令的时候，这里的第一个控制点将是前面曲线的第二个控制点的中心对称点。\n&lt;path d=&quot;M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n\n\n二次贝塞尔曲线\n\n二次贝塞尔曲线仅需要一个控制点，来确认起点和终点的曲线斜率\n// 语法 Q x1 y1, x y (or q dx1 dy1, dx dy)// 举例&lt;path d=&quot;M10 80 Q 95 10 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n\n\n二次贝塞尔曲线简化\n\n当此前已有Q命令的时候，可以省去控制点，自动推算出一个新的控制点。如果此前无Q命令，则推算的控制点为终点，画出来的为直线。\n// 语法T x y (or t dx dy)// 举例&lt;path d=&quot;M10 80 Q 52.5 10, 95 80 T 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n弧形// 语法 A rx ry x-axis-rotation large-arc-flag sweep-flag x y a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy// 举例&lt;path d=&quot;M10 315           L 110 215           A 30 50 0 0 1 162.55 162.45           L 172.55 152.45           A 30 50 -45 0 1 215.1 109.9           L 315 10&quot; stroke=&quot;black&quot; fill=&quot;green&quot; stroke-width=&quot;2&quot; fill-opacity=&quot;0.5&quot;/&gt;\n参数的含义：rx、ry表示椭圆的x轴和y轴的半径x-axis-rotation表示x轴旋转角度，0则表示弧形所在的椭圆是正置的large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧\n填充与边框常用参数列举：\n\n\n\n参数名\n描述\n\n\n\nfill\n填充色\n\n\nstroke\n描边色\n\n\nfill-opacity\n填充色的不透明度\n\n\nstroke-opacity\n描边色的不透明度\n\n\nstroke-width\n描边宽度\n\n\nstroke-linecap\n边框终点的形状：\n\n\nbutt直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点\n\n\n\nsquare的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制\n\n\n\nround表示边框的终点是圆角，圆角的半径也是由stroke-width控制的\n\n\n\nstroke-linejoin\nmiter是默认值，表示用方形画笔在连接处形成尖角，round表示用圆角连接，实现平滑效果。bevel，连接处会形成一个斜接\n\n\nstroke-dasharray\n定义描边虚线类型，由一组用逗号分隔的数字组成。交替表示填色单位长度、空白单位长度。\n\n\n举例\n&lt;svg width=&quot;200&quot; height=&quot;150&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;  &lt;path d=&quot;M 10 75 Q 50 10 100 75 T 190 75&quot; stroke=&quot;black&quot;    stroke-linecap=&quot;round&quot; stroke-dasharray=&quot;5,10,5&quot; fill=&quot;none&quot;/&gt;  &lt;path d=&quot;M 10 75 L 190 75&quot; stroke=&quot;red&quot;    stroke-linecap=&quot;round&quot; stroke-width=&quot;1&quot; stroke-dasharray=&quot;5,5&quot; fill=&quot;none&quot;/&gt;&lt;/svg&gt;\n渐变定义在&lt;defs&gt;标签内，指定id，其他元素通过id引用。可以用于fill、stroke\n线性渐变&lt;svg width=&quot;120&quot; height=&quot;240&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  &lt;defs&gt;      // 默认水平渐变      &lt;linearGradient id=&quot;Gradient1&quot;&gt;        &lt;stop class=&quot;stop1&quot; offset=&quot;0%&quot;/&gt;        &lt;stop class=&quot;stop2&quot; offset=&quot;50%&quot;/&gt;        &lt;stop class=&quot;stop3&quot; offset=&quot;100%&quot;/&gt;      &lt;/linearGradient&gt;          // 垂直渐变      &lt;linearGradient id=&quot;Gradient2&quot; x1=&quot;0&quot; x2=&quot;0&quot; y1=&quot;0&quot; y2=&quot;1&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;50%&quot; stop-color=&quot;black&quot; stop-opacity=&quot;0&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/linearGradient&gt;          // 通过样式执行      &lt;style type=&quot;text/css&quot;&gt;&lt;![CDATA[        #rect1 &#123; fill: url(#Gradient1); &#125;        .stop1 &#123; stop-color: red; &#125;        .stop2 &#123; stop-color: black; stop-opacity: 0; &#125;        .stop3 &#123; stop-color: blue; &#125;      ]]&gt;&lt;/style&gt;  &lt;/defs&gt;  &lt;rect id=&quot;rect1&quot; x=&quot;10&quot; y=&quot;10&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;  &lt;rect x=&quot;10&quot; y=&quot;120&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#Gradient2)&quot;/&gt;&lt;/svg&gt;\nx1、x2、y1、y2指定了渐变的方向\n径向渐变&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;120&quot; height=&quot;240&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  &lt;defs&gt;      &lt;radialGradient id=&quot;RadialGradient1&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/radialGradient&gt;      &lt;radialGradient id=&quot;RadialGradient2&quot; cx=&quot;0.25&quot; cy=&quot;0.25&quot; r=&quot;0.25&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/radialGradient&gt;          // 指定渐变焦点      &lt;radialGradient id=&quot;Gradient&quot;          cx=&quot;0.5&quot; cy=&quot;0.5&quot; r=&quot;0.5&quot; fx=&quot;0.25&quot; fy=&quot;0.25&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/radialGradient&gt;  &lt;/defs&gt;  &lt;rect x=&quot;10&quot; y=&quot;10&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#RadialGradient1)&quot;/&gt;  &lt;rect x=&quot;10&quot; y=&quot;120&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#RadialGradient2)&quot;/&gt;  &lt;rect x=&quot;10&quot; y=&quot;10&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot;        fill=&quot;url(#Gradient)&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot;/&gt;&lt;/svg&gt;\ncx、cy、r 指定了镜像渐变的范围，fx、fy 指定了焦点，即渐变的中心点\n文字x、y指定文本在视口中显示的位置。属性text-anchor指定文本流的方向，可选sstart、middle、end、inherit\n&lt;text x=&quot;10&quot; y=&quot;10&quot;&gt;Hello World!&lt;/text&gt;\n可使用的属性：font-family、font-style、font-weight、font-variant、font-stretch、font-size、font-size-adjust、kerning、letter-spacing、word-spacing和text-decoration其他用法：\n// tspan指定子元素&lt;text&gt;  &lt;tspan font-weight=&quot;bold&quot; fill=&quot;red&quot;&gt;This is bold and red&lt;/tspan&gt;&lt;/text&gt;// tref引用已经定义的文本&lt;text id=&quot;example&quot;&gt;This is an example text.&lt;/text&gt;&lt;text&gt;    &lt;tref xlink:href=&quot;#example&quot; /&gt;&lt;/text&gt;// textPath指定文字沿着路径环绕&lt;path id=&quot;my_path&quot; d=&quot;M 20,20 C 40,40 80,40 100,20&quot; fill=&quot;transparent&quot; /&gt;&lt;text&gt;  &lt;textPath xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#my_path&quot;&gt;    This text follows a curve.  &lt;/textPath&gt;&lt;/text&gt;\n基础变形元素元素用于将属性赋给整个元素集合\n&lt;g fill=&quot;red&quot;&gt;  &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; /&gt;  &lt;rect x=&quot;20&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; /&gt;&lt;/g&gt;\n平移translate&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; transform=&quot;translate(30,40)&quot; /&gt;\n旋转rotate&lt;rect x=&quot;20&quot; y=&quot;20&quot; width=&quot;20&quot; height=&quot;20&quot; transform=&quot;rotate(45)&quot; /&gt;\n其他变换skewX()x轴斜切skewY()y轴斜切scale()缩放\n剪切和遮罩剪切在剪切范围内的元素才会显示，如下代码仅显示上半部的圆形\n&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;  &lt;defs&gt;    &lt;clipPath id=&quot;cut-off-bottom&quot;&gt;      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; /&gt;    &lt;/clipPath&gt;  &lt;/defs&gt;  &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;100&quot; clip-path=&quot;url(#cut-off-bottom)&quot; /&gt;&lt;/svg&gt;\n遮罩以下代码使用渐变遮罩，水平方向不透明度从0到1，则红色的矩形从左到右逐渐显示，叠加后产生渐变效果。\n&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;  &lt;defs&gt;    &lt;linearGradient id=&quot;Gradient&quot;&gt;      &lt;stop offset=&quot;0&quot; stop-color=&quot;white&quot; stop-opacity=&quot;0&quot; /&gt;      &lt;stop offset=&quot;1&quot; stop-color=&quot;white&quot; stop-opacity=&quot;1&quot; /&gt;    &lt;/linearGradient&gt;    &lt;mask id=&quot;Mask&quot;&gt;      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; fill=&quot;url(#Gradient)&quot;  /&gt;    &lt;/mask&gt;  &lt;/defs&gt;  &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; fill=&quot;green&quot; /&gt;  &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; fill=&quot;red&quot; mask=&quot;url(#Mask)&quot; /&gt;&lt;/svg&gt;\n滤镜滤镜元素可参考mdn文档：https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element#%E6%BB%A4%E9%95%9C%E5%85%83%E7%B4%A0以下列举一个阴影效果的代码：\n  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;  &lt;defs&gt;    &lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200%&quot; height=&quot;200%&quot;&gt;      &lt;feOffset result=&quot;offOut&quot; in=&quot;SourceAlpha&quot; dx=&quot;20&quot; dy=&quot;20&quot; /&gt;      &lt;feGaussianBlur result=&quot;blurOut&quot; in=&quot;offOut&quot; stdDeviation=&quot;10&quot; /&gt;      &lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;blurOut&quot; mode=&quot;normal&quot; /&gt;    &lt;/filter&gt;  &lt;/defs&gt;  &lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot;  fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;&lt;/svg&gt;\nfeOffset使用Alpha通道残影偏移，接着feGaussianBlur使用偏移的结果进行高斯模糊，最后feBlend将原图像和上一步模糊后的阴影结合生成最后的效果。\n图片&lt;svg width=&quot;5cm&quot; height=&quot;4cm&quot; version=&quot;1.1&quot;     xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink= &quot;http://www.w3.org/1999/xlink&quot;&gt;\t&lt;image xlink:href=&quot;firefox.jpg&quot; x=&quot;0&quot; y=&quot;0&quot; height=&quot;50px&quot; width=&quot;50px&quot;/&gt;&lt;/svg&gt;\n\n\n如果你没有设置x属性或y属性，它们自动被设置为0。\n如果你没有设置height属性或width属性，它们自动被设置为0。\n如果width属性或height等于0，将不会呈现这个图像。\n\n\nSVG.js的使用以上了解了svg基本的语法，但是自己绘制svg还是比较麻烦，这里记录下SVG.js库的使用，可以简化绘制流程。\n快速使用可以cdn引入和npm安装，这里以Vue为例\nnpm install @svgdotjs/svg.js\n&lt;template&gt;  &lt;div id=&quot;svg&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; SVG &#125; from &quot;@svgdotjs/svg.js&quot;onMounted(() =&gt; &#123;  // 通过addTo方法将SVG挂载到dom上，通过size设置大小  let draw = SVG().addTo(&quot;#svg&quot;).size(&quot;100%&quot;, &quot;100%&quot;);    // 这里绘制一个100大小的矩形，并绑定了点击事件  draw.rect(100, 100).attr(&#123; fill: &quot;#00B1B6&quot; &#125;).click(function() &#123;    this.fill(&#x27;#ff0000&#x27;)  &#125;);&#125;)&lt;/script&gt;\n常用绘图绘图方法名称和svg形状名称基本一致，然后通过attr可设置属性，同时也可以通过属性名直接设置。使用方式和jQuery类似，支持链式调用。\n// 绘制矩形，设置矩形圆角var rect = draw.rect(100, 100)rect.radius(10)// 绘制占据100，直径半径50的圆draw.circle(100).radius(50)// 绘制长宽200/100的椭圆，x、y半径分别为75、50var ellipse = draw.ellipse(200, 100).radius(75, 50)// 直线绘制var line = draw.line(0, 0, 100, 150).stroke(&#123; width: 1 &#125;)// 多线段绘制var polyline = draw.polyline(&#x27;0,0 100,50 50,100&#x27;).fill(&#x27;none&#x27;).stroke(&#123; width: 1 &#125;)var polyline1 = draw.polyline([[0,0], [100,50], [50,100]])var polyline2 = draw.polyline([0,0, 100,50, 50,100])// 路径的绘制draw.path(&#x27;M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z&#x27;)// 图片绘制，图片加载后的回调处理var image = draw.image(&#x27;/path/to/image.jpg&#x27;, function (event) &#123;  // image loaded  // this is the loading event for the underlying img element  // you can access the natural width and height of the image with  // event.target.naturalWidth, event.target.naturalHeight&#125;)// 线性渐变var gradient = draw.gradient(&#x27;linear&#x27;, function(add) &#123;  add.stop(0, &#x27;#333&#x27;)  add.stop(1, &#x27;#fff&#x27;)&#125;)rect.fill(gradient)// 镜像渐变var gradient = draw.gradient(&#x27;radial&#x27;, function(add) &#123;  add.stop(0, &#x27;#333&#x27;)  add.stop(1, &#x27;#fff&#x27;)&#125;)gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)\n位置\n通过attr\n// 矩形根据左上角移动rect.attr(&#123; x: 20, y: 60 &#125;)// 圆形根据中心点移动circle.attr(&#123; cx: 50, cy: 40 &#125;)\n通过x、y坐标设置\n// 通过坐标轴移动方法时，均可以使用左上角和中心点，仅支持无单位坐标rect.cx(20).cy(60)circle.x(50).y(40)\n通过move方法\n// 通过move方法指定坐标，左上角基准rect.move(200, 350)// 等价于rect.x(200).y(350)// 中心点移动rect.center(150, 150)// 等价于rect.cx(200).cy(350)// 相对坐标移动rect.dmove(10, 30)// 等价于rect.dx(10).dy(30)\n动画动画使用animate方法，再调用attr、move等方法之前使用。以下为使用的举例：\n\n默认\n\n\n默认情况下duration将设置为400，delay将设置为0并when设置为after。\nrect.animate().move(150, 150)\n\n\n常用参数\n\n第一个是duration，第二个delay和第三个when。when参数的取值：\n\nnow：在此调用执行后立即播放动画\nabsolute或start：将动画安排到时间线上的绝对时间\nrelative：安排动画相对于其旧开始时间播放（对 animate() 调用无用）\nlast或after：在时间轴上最后一个动画之后播放动画。如果没有，则立即播放动画（请参阅now）rect.animate(2000, 1000, &#x27;now&#x27;).attr(&#123; fill: &#x27;#f03&#x27; &#125;)\n\n\n对象形式多参数\nrect.animate(&#123;  duration: 2000,  delay: 1000,  when: &#x27;now&#x27;,  swing: true,  times: 5,  wait: 200&#125;).attr(&#123; fill: &#x27;#f03&#x27; &#125;)// 多个动画链接在一起rect.animate().attr(&#123; fill: &#x27;#f03&#x27; &#125;).animate().dmove(50,50)// 动画之间添加延迟rect.animate().attr(&#123; fill: &#x27;#f03&#x27; &#125;).delay(200).animate().dmove(50,50)// 直接在动画里面加延迟rect.animate().attr(&#123; fill: &#x27;#f03&#x27; &#125;).animate(&#123;delay: 200&#125;).dmove(50,50)\n缓动设置\n\n\n缓动类型包括：\n\n&lt;&gt;: ease in and out\n&gt;: ease out\n&lt;: ease in\n-: linear\n函数\nbeziere(x1, y1, x2, y2)\nstep(steps, stepPosition) draw.circle(100).radius(50).fill(&quot;#ccB1B6&quot;).animate(&#123; duration: 2000 &#125;).ease(&#x27;&lt;&#x27;).dmove(100);\n事件支持常见事件的绑定，例如：click、dblclick、mousedown、mouseup、mousemove、mouseout、mousemove、touchstart、touchmove、touchleave、touchend、touchcancel等单事件绑定可直接通过事件名绑定：element.click(function() &#123;  this.fill(&#123; color: &#x27;#f06&#x27; &#125;)&#125;)// 解绑事件element.click(null)\non绑定可通过on绑定单个或多个事件：// 单个事件绑定var click = function() &#123;  this.fill(&#123; color: &#x27;#f06&#x27; &#125;)&#125;element.on(&#x27;click&#x27;, click)// 多个事件绑定element.on([&#x27;click&#x27;, &#x27;mouseover&#x27;], handler)element.on(&#x27;click mouseover&#x27;, handler)// 指定上下文element.on(&#x27;click&#x27;, click, window)// 解绑事件element.off(&#x27;click&#x27;, click)element.off(&#x27;click&#x27;)element.off([&#x27;click&#x27;, &#x27;mouseover&#x27;])element.off(&#x27;click mouseover&#x27;)element.off()\n自定义事件自定义事件的绑定：element.on(&#x27;myevent&#x27;, function() &#123;  alert(&#x27;ta-da!&#x27;)&#125;)\n事件和自定义事件可以通过fire、dispatch触发，区别在于fire返回element、而dispatch返回事件对象。// 触发事件element.fire(&#x27;myevent&#x27;)// 携带参数element.fire(&#x27;myevent&#x27;, &#123;some:&#x27;data&#x27;&#125;)// dispatch的使用var event = element.dispatch(event)\n结语除了SVG.js外还有其他的库可以方便操作svg，也可以自己封装一些常用的操作。这里再推荐一个草绘风格的绘图库，Rough.js\n\n","categories":["前端"],"tags":["svg","SVG.js"]},{"title":"设计模式","url":"/2021/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"单例模式惰性单例模式封装\nvar getSingle = function (fn) &#123;    var result;    return function () &#123;        return result || ( result = fn.apply(this, arguments) );    &#125;&#125;\n\n策略模式\n定义：定义一系列的算法，把他们一个个封装起来，并使他们可以相互替换。除了算法外，策略模式还可以用来封装一系列的业务规则，例如：表单校验，业务规则可以对应表单校验的规则和错误的提示语。定义好规则策略后，需要校验的地方传入规则名和错误提示即可。\n\n代理模式\n定义：代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。\n\n保护代理：可以增加条件做过滤，拒绝掉一部分的请求，控制不同权限的对象对目标对象的访问虚拟代理：对耗时或者可合并的操作等，做延迟处理，在合适的时机触发。例如：加载图片、合并接口请求等。\n合并请求的虚拟代理例子：\nvar synchromousFile = function ( id ) &#123;    console.log(&#x27;开始同步文件，id为&#x27; + id);&#125;;var proxySynchronousFile = (function () &#123;    var cache = [], // 保存一段时间内需要同步的ID集合    timer;    return function( id ) &#123;        cache.push(id);        if ( timer ) &#123;            return;        &#125;        timer = setTimeout(function() &#123;            synchromousFile( cache.join(&#x27;,&#x27;)); // 2秒后向本体发送需要同步的ID集合            clearTimeout( timer );            timer = null;            cache.length = 0; //清空ID集合        &#125;, 2000)    &#125;&#125;)();\n发布-订阅模式\n定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。优点：一为时间上的解耦，二为对象之间的解耦。缺点：过多的使用会使得模块之间的联系被隐藏到了背后。\n\n以下为全局的发布-订阅对象：\nvar Event = (function () &#123;    var clientList = &#123;&#125;,        listen,        trigger,        remove;        listen = function (key, fn) &#123;        if (!clientList[ key ]) &#123;            clientList[ key ] = [];        &#125;        clientList[ key ].push( fn );    &#125;;    trigger = function () &#123;        var key = Array.prototype.shift.call( arguments ),            fns = clientList[ key ];            if ( !fns || fns.length === 0) &#123;                return false;            &#125;            for ( var i = 0, fn; fn = fns[ i++ ]; ) &#123;                fn.apply( this, arguments);            &#125;    &#125;    remove = function ( key, fn ) &#123;        var fns = clientList[ key ];        if ( !fns ) &#123;            return false;        &#125;        if ( !fn ) &#123;            fns &amp;&amp; ( fns.length = 0);        &#125; else &#123;            for ( var l = fns.length - 1; l &gt;= 0; l--) &#123;                var _fn = fns[ l ];                if ( _fn === fn ) &#123;                    fns.splice( l, 1);                &#125;            &#125;        &#125;    &#125;;    return &#123;        listen: listen,        trigger: trigger,        remove: remove    &#125;&#125;)();\n\n命令模式\n定义：指的是一个执行某些特定事情的指令。最常用的场景：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。命令模式支持撤销、排队、宏命令等。\n\n使用闭包的命令模式：\nvar setCommand = function ( button, func ) &#123;    button.onclick = function () &#123;        func();    &#125;&#125;;var MenuBar = &#123;    refresh: function () &#123;        console.log( &#x27;刷新&#x27; );    &#125;&#125;;var RefreshMenuBarCommand = function ( receiver ) &#123;    return function () &#123;        receiver.refresh();    &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar );setCommand( button1, refreshMenuBarCommand);\n\n组合模式组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明。\n\n表示树形结构。通过回顾上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象的execute方法，程序会递归调用组合对象下面的叶对象的execute方法，所以我们的万能遥控器只需要一次操作，便能依次完成关 门、打开电脑、登录QQ这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。\n利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。\n\n// 创建一个宏命令var MacroCommand = function()&#123;    return &#123;        // 宏命令的子命令列表        commandsList: [],        // 添加命令到子命令列表        add: function( command )&#123;            this.commandsList.push( command );        &#125;,        // 依次执行子命令列表里面的命令        execute: function()&#123;            for ( var i = 0, command; command = this.commandsList[ i++ ]; )&#123;                command.execute();            &#125;        &#125;    &#125;&#125;;&lt;!--打开空调命令--&gt;var openAcCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开空调&#x27; );    &#125;&#125;;&lt;!--打开电视和音响--&gt;var openTvCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开电视&#x27; );    &#125;&#125;;var openSoundCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开音响&#x27; );    &#125;&#125;;//创建一个宏命令var macroCommand1 = MacroCommand();//把打开电视装进这个宏命令里macroCommand1.add(openTvCommand)//把打开音响装进这个宏命令里macroCommand1.add(openSoundCommand)&lt;!--关门、打开电脑和打登录QQ的命令--&gt;var closeDoorCommand = &#123;    execute: function()&#123;        console.log( &#x27;关门&#x27; );    &#125;&#125;;var openPcCommand = &#123;    execute: function()&#123;        console.log( &#x27;开电脑&#x27; );    &#125;&#125;;var openQQCommand = &#123;    execute: function()&#123;        console.log( &#x27;登录QQ&#x27; );    &#125;&#125;;//创建一个宏命令var macroCommand2 = MacroCommand();//把关门命令装进这个宏命令里macroCommand2.add( closeDoorCommand );//把开电脑命令装进这个宏命令里macroCommand2.add( openPcCommand );//把登录QQ命令装进这个宏命令里macroCommand2.add( openQQCommand );&lt;!--把各宏命令装进一个超级命令中去--&gt;var macroCommand = MacroCommand();macroCommand.add( openAcCommand );macroCommand.add( macroCommand1 );macroCommand.add( macroCommand2 );\n\n享元模式\n享元模式的核心是运用共享技术来有效支持大量细粒度的对象，如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用。\n\n享元模式要求对象的属性划分为内部状态和外部状态，如何划分：\n\n内部状态存储于对象内部\n内部状态可以被一些对象共享\n内部状态独立于具体的场景，通常不会变化\n外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。\n\n示例：文件上传\nvar Upload = function(uploadType) &#123;  this.uploadType = uploadType;&#125;​/* 删除文件（内部状态） */Upload.prototype.delFile = function(id) &#123;  uploadManger.setExternalState(id, this);  // 把当前id对应的外部状态都组装到共享对象中  // 大于3000k提示  if(this.fileSize &lt; 3000) &#123;    return this.dom.parentNode.removeChild(this.dom);  &#125;  if(window.confirm(&quot;确定要删除文件吗？&quot; + this.fileName)) &#123;    return this.dom.parentNode.removeChild(this.dom);  &#125;&#125;/** 工厂对象实例化  *  如果某种内部状态的共享对象已经被创建过，那么直接返回这个对象 *  否则，创建一个新的对象 */var UploadFactory = (function() &#123;    var createdFlyWeightObjs = &#123;&#125;;    return &#123;        create: function(uploadType) &#123;            if(createdFlyWeightObjs[ uploadType ]) &#123;                return createdFlyWeightObjs[ uploadType ]            &#125;            return createdFlyWeightObjs[ uploadType ] = new Upload( uploadType );        &#125;    &#125;&#125;)();/* 管理器封装外部状态 */var uploadManger = (function() &#123;  var uploadDatabase = &#123;&#125;;​  return &#123;    add: function(id, uploadType, fileName, fileSize) &#123;      var flyWeightObj = UploadFactory.create(uploadType);      var dom = document.createElement(&#x27;div&#x27;);      dom.innerHTML = &quot;&lt;span&gt;文件名称：&quot; + fileName + &quot;，文件大小：&quot; + fileSize +&quot;&lt;/span&gt;&quot;              + &quot;&lt;button class=&#x27;delFile&#x27;&gt;删除&lt;/button&gt;&quot;;​      dom.querySelector(&quot;.delFile&quot;).onclick = function() &#123;        flyWeightObj.delFile(id);      &#125;;      document.body.appendChild(dom);​      uploadDatabase[id] = &#123;        fileName: fileName,        fileSize: fileSize,        dom: dom      &#125;;​      return flyWeightObj;    &#125;,    setExternalState: function(id, flyWeightObj) &#123;      var uploadData = uploadDatabase[id];      for(var i in uploadData) &#123;        flyWeightObj[i] = uploadData[i];      &#125;    &#125;  &#125;;&#125;)();/*触发上传动作*/var id = 0;window.startUpload = function(uploadType, files) &#123;  for(var i=0,file; file = files[i++];) &#123;    var uploadObj = uploadManger.add(++id, uploadType, file.fileName, file.fileSize);  &#125;&#125;;​/* 测试 */startUpload(&quot;plugin&quot;, [  &#123;    fileName: &#x27;1.txt&#x27;,    fileSize: 1000  &#125;,&#123;    fileName: &#x27;2.txt&#x27;,    fileSize: 3000  &#125;,&#123;    fileName: &#x27;3.txt&#x27;,    fileSize: 5000  &#125;]);startUpload(&quot;flash&quot;, [  &#123;    fileName: &#x27;4.txt&#x27;,    fileSize: 1000  &#125;,&#123;    fileName: &#x27;5.txt&#x27;,    fileSize: 3000  &#125;,&#123;    fileName: &#x27;6.txt&#x27;,    fileSize: 5000  &#125;]);\n\n职责链模式\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n例子：异步职责链的实现\n// Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点var Chain = function ( fn ) &#123;    this.fn = fn;    this.successor = null;&#125;Chain.prototype.setNextSuccessor = function ( successor ) &#123;    return this.successor = successor;&#125;// 对于ret的判断可以用于同步的职责链模式Chain.prototype.passRequest = function () &#123;    var ret = this.fn.apply( this, arguments);    if ( ret === &#x27;nextSuccessor&#x27; ) &#123;        return this.successor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );    &#125;    return ret;&#125;// 异步时ret的return值没有，此时无法接收，因此采用next回调的方式Chain.prototype.next = function () &#123;    return this.nextSuccessor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );&#125;var fn1 = new Chain(function()&#123;    console.log( 1 );    return &#x27;nextSuccessor&#x27;;&#125;);var fn2 = new Chain(function()&#123;    console.log( 2 );    var self = this;    setTimeout(function()&#123;        self.next();    &#125;, 1000 );&#125;);var fn3 = new Chain(function()&#123;    console.log( 3 );&#125;);fn1.setNextSuccessor( fn2 ).setNextSuccessor( fn3 );fn1.passRequest();\n\n用AOP实现职责链\nFunction.prototype.after = function( fn )&#123;    var self = this;    return function()&#123;        var ret = self.apply( this, arguments );        if ( ret === &#x27;nextSuccessor&#x27; )&#123;            return fn.apply( this, arguments );        &#125;        return ret;    &#125;&#125;;// 此处的order500yuan、order200yuan、orderNormal为订单处理的函数，此处未列出var order = order500yuan.after( order200yuan ).after( orderNormal );order( 1, true, 500 ); // 输出：500元定金预购，得到100优惠券order( 2, true, 500 ); // 输出：200元定金预购，得到50优惠券order( 1, false, 500 ); // 输出：普通购买，无优惠券\n\n中介者模式\n中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。\n\n例子：游戏中使用中介者控制游戏状态\n玩家对象的生成：\nfunction Player (name, teamColor) &#123;    this.name = name;    this.teamColor = teamColor;    this.state = &#x27;alive&#x27;;&#125;;Player.prototype.win = function () &#123;    console.log(`$&#123;this.name&#125; won!`);&#125;;Player.prototype.lose = function () &#123;    console.log(`$&#123;this.name&#125; lost!`);&#125;;// 玩家死亡Player.prototype.die = function () &#123;    this.state = &#x27;dead&#x27;;    // 给中介者发送消息，玩家死亡    playerDirector.ReceiveMessage( &#x27;playDead&#x27;, this );&#125;// 移除玩家Player.prototype.remove = function () &#123;    // 给中介者发送消息，玩家移除    playerDirector.ReceiveMessage( &#x27;removePlayer&#x27;, this );&#125;// 玩家换队Player.prototype.remove = function ( color ) &#123;    // 给中介者发送消息，玩家换队    playerDirector.ReceiveMessage( &#x27;changeTeam&#x27;, this, color );&#125;// 生成玩家的工厂函数var palyerFactory = function ( name, teamColor ) &#123;    var newPlayer = new Player( name, teamColor );    // 给中介者发动消息，新增玩家    playerDirecotor.ReceiveMessage( &#x27;addPlayer&#x27;, newPlayer );    return newPlayer;&#125;\n中介者playerDirector的实现：\n\n利用发布—订阅模式。将playerDirector实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirector，playerDirector处理消息后将反馈发送给其他player。\n在playerDirector中开放一些接收消息的接口，各player可以直接调用该接口来给playerDirector发送消息，player只需传递一个参数给playerDirector，这个参数的目的是使playerDirector可以识别发送者。同样，playerDirector接收到消息之后会将处理结果反馈给其他player。\n\n以下采取开发接口的方式：\nvar playerDirector = ( function () &#123;    var players = &#123;&#125;, // 保存所有玩家        operations = &#123;&#125;; // 中介者可以执行的操作    // 新增一个玩家    operations.addPlayer = function ( player ) &#123;        var teamColor = player.teanmColor;        players[ teamColor ] = players[ teamColor ] || [];        players[ teamColor ].push( player );    &#125;    // 移除一个玩家    operations.removePlayer = function ( player ) &#123;        var teamColor = player.teamColor,            teamPlayers = players[ teamColor ] || []        for ( var i = teamPlayers.length - 1; i &gt;= 0; i-- )&#123;   // 遍历删除            if ( teamPlayers[ i ] === player )&#123;                teamPlayers.splice( i, 1 );            &#125;        &#125;    &#125;    // 玩家换队    operations.changeTeam = function ( player, newTeamColor ) &#123;        operations.removePlayer( player );        player.teamColor = newTeamColor;        operations.addPlayer( player );    &#125;    // 玩家死亡    operations.playerDead = function( player )&#123;     // 玩家死亡        var teamColor = player.teamColor,            teamPlayers = players[ teamColor ];   // 玩家所在队伍        var all_dead = true;        for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;            if ( player.state !== &#x27;dead&#x27; )&#123;                all_dead = false;                break;            &#125;        &#125;        if ( all_dead === true )&#123;   // 全部死亡            for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;                player.lose();   // 本队所有玩家lose            &#125;            for ( var color in players )&#123;                if ( color !== teamColor )&#123;                    var teamPlayers = players[ color ];   // 其他队伍的玩家                    for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;                        player.win();   // 其他队伍所有玩家win                    &#125;                &#125;            &#125;        &#125;    &#125;;    // 开发接口    var ReceiveMessage = function () &#123;        // 第一个参数为消息的类型        var message = Array.prototype.shift.call( arguments );        operations[ message ].apply( this, arguments );    &#125;    return &#123;        ReceiveMessage: ReceiveMessage    &#125;&#125;)();\n\n装饰者模式\n装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。\n\n一个简单的例子：\nvar a = function()&#123;    alert (1);&#125;var _a = a;a = function()&#123;    _a();    alert (2);&#125;a();\n\n用AOP装饰函数\nFunction.prototype.before = function ( beforeFn ) &#123;    var _self = this; // 保存原函数的引用    return function () &#123; // 返回包含了原函数和新函数的“代理”函数        beforeFn.apply( this, arguments ); // 执行新函数，保证this不被劫持        return _self.apply( this, arguments ); // 执行原函数并返回原函数的结果，保证this不被劫持    &#125;    &#125;Function.prototype.after = function( afterfn )&#123;    var _self = this;    return function()&#123;        var ret = _self.apply( this, arguments );        afterfn.apply( this, arguments );        return ret;    &#125;&#125;// 使用window.onload = function()&#123;    alert (1);&#125;window.onload = ( window.onload || function()&#123;&#125; ).after(function()&#123;    alert (2);&#125;).after(function()&#123;    alert (3);&#125;).after(function()&#123;    alert (4);&#125;);\n装饰者模式和代理模式\n代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。\n\n状态模式\n定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。\n\n状态模式的通用结构\nvar Light = function()&#123;    // 实例化每一个状态对象    this.offLightState = new OffLightState( this );    // 持有状态对象的引用    this.weakLightState = new WeakLightState( this );    this.strongLightState = new StrongLightState( this );    this.superStrongLightState = new SuperStrongLightState( this );    this.button = null;&#125;;Light.prototype.init = function () &#123;    var button = document.createElement( &#x27;button&#x27; ),        self = this;    this.button = document.body.appendChild( button );    this.button.innerHTML = &#x27;开关&#x27;;    this.currState = this.offLightState; // 设置默认状态    this.button.onclick = function () &#123;        self.currState.buttonWasPressed();    &#125;&#125;// 列举一个状态对象，关灯状态对象var OfflightState = function( light ) &#123;    this.light = light;&#125;OfflightState.prototypr.buttonWasPressed = function () &#123;    console.log(&#x27;弱光&#x27;);    this.light.setState( this.light.weakLightState );&#125;\n\n状态机：使用闭包实现将客户的操作委托给状态对象，此委托需要处理this的劫持\nvar delegate = function ( client, delegation ) &#123;    return &#123;        buttonWasPressed: function () &#123;            return delegation.buttonWasPressed.apply( client, arguments);        &#125;    &#125;&#125;;var FSM = &#123;    off: &#123;        buttonWasPressed: function()&#123;            console.log( &#x27;关灯&#x27; );            this.button.innerHTML = &#x27;下一次按我是开灯&#x27;;            this.currState = this.onState;        &#125;    &#125;,    on: &#123;        buttonWasPressed: function()&#123;            console.log( &#x27;开灯&#x27; );            this.button.innerHTML = &#x27;下一次按我是关灯&#x27;;            this.currState = this.offState;        &#125;    &#125;&#125;;var Light = function () &#123;    this.offState = delegation( this, FSM.off );    this.onState = delegation( this, FSM.on );    this.currState = this.offState;    this.button = null;&#125;Light.prototype.init = function () &#123;    var button = document.createElement( &#x27;button&#x27; );    button.innerHTML = &#x27;已关灯&#x27;;    this.button = document.body.appendChild( button );    this.button.onclick = function () &#123;        self.currState.buttonWasPressed();    &#125;&#125;var light = new Light();light.init();\n\n适配器模式\n适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。实际项目中封装组件时，经常遇到组件定义的接口和后台返回的数据无法完全对应上，这时一个apater函数转化数据是比较方便的选择。\n\n","categories":["前端"],"tags":["javascript"]},{"title":"网络知识-《网络是怎样连接的》一书学习","url":"/2022/06/10/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/","content":"整理《网络是怎样连接的》一书的知识要点，对整个网络有个大概的了解。在开始之前我想在本书中找到部分常被问到的问题的答案：\n\n从输入网址到页面加载出来发生了什么？\n网络分层，和各分层的作用？\nTCP、UDP协议？    概要概念整理\n\n\n名称\n含义\n\n\n\n接入网\n互联网的入口线路称为接入网。一般来说，我们可以用电话线、ISDN、ADSL、有线电视、光线、专线等多种通信线路来接入互联网，这些通信线路统称为接入网\n\n\n接入点（Point of Presence, PoP）\n接入点的实体是一台专为运营商设计的路由器，接入点的后面就是互联网的骨干部分了。网络包首先通过接入网被发送到接入点，然后再从这里被发送到全国甚至全世界\n\n\n套接字\n套接字只是一个概念。在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP地址、端口号、通信操作的进行状态等。这些控制信息可以说是套接字的实体。\n\n\nMTU\n一个网络包的最大长度，以太网中一般为1500字节。\n\n\nMSS\n一个网络包的最大长度，以太网中一般为1500字节。\n\n\n窗口大小\nTCP缓存区能接收的最大数据量，决定了数据传输滑动窗口的并发传输的上限\n\n\n终端节点\n包的发送方和接收方都称为终端节点，中间的转发设备称为转发节点或中间节点\n\n\n网卡的作用\n实现数字信号和电信号之间的相互转化\n\n\nARP\nAddress Resolution Protocol，地址解析协议。查询IP对应的MAC地址，查询方法是广播，对同一子网的所有设备进行广播来获取MAC地址\n\n\n路由表\n记录网络包地址和对应转发路由器地址以及发送包的网络接口的表，IP模块使用改表来获取目标地址IP组装包的IP头，可以通过route print命令来显示路由表\n\n\n以太网\n3个性质：将包发送到MAC头部的接收方MAC地址代表的目的地，用发送方MAC地址识别发送方，用以太类型识别包的内容\n\n\n传输速率\n将数字信号转化为电信号的速率，例如每秒将10Mbit的数字信息转换为电信号发送出去，则速率就是10 Mbit/s\n\n\nPHY（MAU）\nPhysical Layer Device(物理层装置)(100 Mbit/s以上称为PHY)、Medium Attachment Unit(介质连接单元)，其作用是对MAC模块产生的信号(电信号)进行格式转换，转化成可以在网线上传输的格式。此外，监控接收线路中有没有信号进来也是其作用。在半双工模式下(集线器)发送和接收不能同时进行，否则会产生信号碰撞，在全双工模式下(交换机)发送和接收可以同时进行\n\n\nICMP\nInternet Control Message Protocol，Internet控制报文协议。当包传输过程中发生错误，用来发送控制消息\n\n\nFCS\nFCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误\n\n\nSFD\n起始帧分界符，用来确定帧的起始位置\n\n\n接入网\n指连接互联网与家庭、公司网络的通信线路。一般家用的接入网方式包括ADSL、FTTH、CATV、电话线、ISDN等，公司则还可能使用专线\n\n\nBAS\nBroadband Access Server，宽带接入服务器，也是一种路由器。\n\n\nPPP\nPoint-to-Point Protocol，点到点协议。它是电话线、ISDN等通信线路所使用的一种协议，集成了用户认证、配置下发、数据压缩、加密等各种功能。\n\n\nATM\nAsynchronous Transfer Mode，异步传输。它是在以电话线为载体的传统电话技术基础上扩展出来的一种通信方式。它的数据传输是以“信元”为单位来进行的，这和以包为单位传输数据的TCP/IP很像，但这种方式并不适用于计算机通信。\n\n\nDSLAM\nDSL Access Multiplexer，数字用户线接入复用设备。它是一种电话局用的多路ADSL Modem，可以理解为将多个ADSL Modem整合在一个外壳里的设备。\n\n\nONU\nOptical Network Unit，光网络单元。它和光纤收发器一样，可以将电信号转换成光信号，除此之外还具有和电话局的OLT相互配合避免信号碰撞的功能。这个设备有时也被叫做终端盒，因此终端盒这个词本身是对光纤收发器和ONU等光纤终端设备的统称。\n\n\nOLT\nOptical Line Terminal，光线路终端。\n\n\n\n\n网络流程浏览器生成消息生成HTTP请求消息浏览器先解析URL，根据HTTP协议的要求生成对应格式请求信息。web服务器会根据请求信息返回对应的响应信息。请求信息：请求行（方法、URI、HTTP版本）、消息头（请求头）、消息体（请求携带的数据，例如post请求的表单数据等）响应消息：状态行（HTTP版本、状态码、响应短语）、消息头（响应头）、消息体（具体响应的数据）此处需要补充的是常见的消息头、以及缓存相关的消息头设置\nDNS解析\nIP的基本知识\n\n以下两图可以了解到IP的表示方式、子网掩码的作用如图，IP地址分为两部分：网络号、主机号，两部分的总长度是32比特，但具体的结构实际上不固定，具体怎么表示由子网掩码确定。子网掩码二进制表示中，为1的部分对应网络号，为0的部分对应主机号。例如：255.255.255.0 这样表示的是前24比特为网络号，后8比特为主机号，图中也可以简写成”IP/24”的格式来简化子网掩码的表达。\n\nDNS查询的发出\n\nDNS查询操作由计算机上的解析器(resolver)通过调用Socket库发起，Socket库是调用网络功能的程序组件集合，通过gethostbyname向DNS服务器查询域名的IP\nDNS接力\n客户端查询信息格式\n\n\n域名： 服务器、邮件服务器（邮件地址中@后面的部分）的名称\nClass：在最早设计DNS方案时，DNS在互联网以外的其他网络中的应用也被考虑到了，而Class就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此Class的值永远是代表互联网的IN\n记录类型：表示域名对应何种类型的记录\nA：IP地址\nMX：邮件服务器\nPTR：根据IP反查域名\nCNAME：域名相关别名\nNS：查询DNS服务器的IP\nSOA：查询域名属性\n\n\n\n\n域名的层级以及查找逻辑\n\n自己购买的域名做域名解析的时候一般会添加子域名，这就代表了域名的一个层级，实际上域名有很多的层级，域名从右到左则表示了整个域名的层级。举例：www.demo.starsea.club，这里看似`club`是最上层，实际上上面还有一层——根域，根域保存了`club`、`com`等层级的DNS服务器信息，因此从根域开始可以往下一直查找到对应域名的DNS服务器。分配给根域DNS服务器的IP地址在全世界仅有13个（不代表服务器只有13个），其地址被写到了DNS服务器程序的配置文件中，即任何DNS服务器都可以找到根域服务器。来描述下整个查找的过程：客户端首先会访问最近的一台DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址），最近的DNS服务器可以找到根域服务器，根域服务器根据域名的层级分级将查询任务给到了不同的DNS服务器，知道查找到为止。这个是一般的流程，但实际上有两种情况要考虑：1、为了加快查询，DNS服务器是有做缓存的（缓存当然也会有有效期的控制），当在缓存期限内查询过，则直接返回对应的缓存查询结果；2、一个DNS服务器通常会存多域名，因此上述的层层分发下去查找也是不确定的，如果这个域名下要查找的子域名已经在当前DNS服务器上了，那就直接返回查询结果了。\n委托协议栈发送消息查询到IP之后，客户端需要委托协议栈来发送HTTP消息给Web服务器，此处也需要通过Socket库。分为以下四个步骤。\n\n创建套接字阶段：调用socket创建套接字，套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中，此后得收发数据等操作都是通过这个描述符区分的。\n连接阶段：调用Socket库中的名为connect的程序组件将管道连接到服务器得套接字上，携带的参数有：描述符、服务器IP地址、端口号。\n通信阶段：收发数据。发送数据使用Socket的write组件完成，接收数据使用read组件。\n断开阶段：调用Socket库的close程序组件断开管道并删除套接字。断开操作一般由Web服务器发起，Web服务器发送完响应消息后主动执行断开操作，之后客户端的套接字也会进入断开阶段。\n\n协议栈和网卡TCP协议的收发操作浏览器、邮件等一般应用程序收发数据时用TCP;DNS查询等收发较短的控制数据时用UDP。\n创建套接字套接字只是一个概念，其实体可以理解为记录了用于控制通信操作的控制信息，例如通信对象的IP地址、端口号、通信操作的进行状态等的内存空间。协议栈是根据套接字中记录的控制信息来工作的。创建套接字的过程为：应用程序调用socket申请创建套接字，协议栈首先会分配用于存放一个套接字所需的内存空间，并写入初始状态的控制信息。然后返回该套接字的描述符，之后应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。\n连接服务器\n连接相关的概念\n\n连接操作的目的：把服务器的IP地址和端口号等信息告知协议栈；客户端向服务器传达开始通信的请求；分配缓冲区（存放要收发的数据的内存空间）TCP头部信息如下：通信操作中使用的控制信息分为两类：\n\n头部中记录的信息：客户端和服务器相互联络时交换的控制信息，在整个通讯过程中均需要。2）套接字（协议栈中的内存空间）中记录的信息：应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。\n\n\n连接操作的实际过程\nconnect (&lt;描述符&gt;, &lt;服务器IP地址和端口号&gt;, …)\n\n\n\n\n在TCP模块处创建表示连接控制信息的头部，通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字。将头部中的控制位的SYN比特设置为1，用以表示连接；此外还需要设置适当的序号和窗口大小。\n接下来TCP模块会将信息传递给IP模块并委托它进行发送\n然后服务器上的IP模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字，套接字中会写入相应的信息，并将状态改为正在连接。\n上述操作完成后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特，此外，在返回响应时还需要将ACK控制位设为1，表示已经接收到相应的网络包。\n接下来，服务器TCP模块会将TCP头部传递给IP模块，并委托IP模块向客户端返回响应。\n客户端收到网络包之后，同样经过IP、TCP得到转化后的数字信息，SYN为1则表示连接成功，这时会向套接字中写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕。此外，还要答复服务器，将ACK比特设置为1并发回服务器，告诉服务器刚才的响应包已经收到。\n以上连接过程则是“三次握手”的过程：1. 客户端发起连接SYN比特设置位1；2. 服务端接收到消息后，回复SYN比特为1、ACK控制位设为1、同时生成随机序号方便客户端设置网络包序号；3. 客户端收到消息后，回复ACK比特设置为1，表示响应完成。三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。\n\n\n\n收发数据\n将HTTP请求消息交给协议栈\n\n收发数据的起点：应用程序调用write将要发送的数据交给协议栈，协议栈仅关心一定长度的二进制字节序列。协议栈发送数据的逻辑：1.  数据长度达到网络包的MTU(最大传输单元，包含头部。不包含头部的叫MSS)，在以太网中一般是1500字节；2. 时间达到。协议栈平衡数据大小和时间来提高发送效率和性能。此外，应用程序也可以指定包立即发出。\n\n对较大的数据进行拆分\n\n当发送内容超过MSS（总长度超过MTU）的情况下，则需要对缓存区中的数据进行拆分，每块加上TCP头部，加上套接字中的接收方和发送方数据给到IP模块进行发送操作。拆分之后接收方如何组装数据？此处，TCP头部的序号则起到了作用，初始序号在连接阶段双方已互相提供，此后根据每个包开始的字节数以及包的长度可以计算序号。同样，接收方需要通过ACK号告知发送方哪些拆分的包接收到了。\n\nACK号确保数据收发可靠\n\nACK号的结算和作用：接收方根据序号和包长度计算出ACK号，然后返回ACK给发送方，发送方则可以知道哪些包已经发送成功了。如果超时未收到则发送失败，TCP会进行重传，如果重传到达上限则强制结束通信。如果成功了，那缓存区保存的已发送的包则可以删除了。ACK号等待时间：上述说明中超时未收到ACK号的返回则认为失败进行重传，这个等待的时间并不是固定的。TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应缩短等待时间。\n\n滑动窗口管理ACK号\n\n上述ACK号的等待并非串行，为了收发效率，等待ACK号的同时，其他收发操作也在进行。但是如果无限制的并发，接收缓冲区将会被撑爆，因此，接收方TCP头部中的窗口字段将自己能接收的数据量告知发送方，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。更新窗口信息和ACK号的返回并不是独立的，都是TCP头部的字段，因此有个类似防抖的操作，可以同时回传窗口信息和ACK号，也可能单独回传，用来减少网络包提高效率。\n\n接收HTTP响应消息\n\n\n浏览器在委托协议栈发送请求消息之后，会调用read程序来获取响应消息，控制流程转移到协议栈\n挂起：协议栈尝试从缓存区读取数据，但是此时数据还没返回，因此先挂起，等数据返回后继续操作（如何继续这块在下一章有讲解）。\n数据接收：协议栈会检查收到的数据块和TCP头部的内容，判断是否有数据丢失，如果没有问题则返回ACK号。协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将接收到的数据复制到应用程序指定的内存地址中。断开连接断开操作断开操作可以由服务器和客户端任意一方发起。在Web中，Web服务器再返回响应消息，这时收发数据的过程就全部结束了，服务器一方会发起断开过程。整个断开过程就是通常的“四次挥手”的说法。以下以服务端先断开位列说明：\n\n\n服务端发送FIN：服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的TCP头部，将控制位中的FIN比特设为1。接下来，协议栈会委托IP模块向客户端发送数据。\n客户端返回ACK号：客户端收到服务器发来的FIN为1的TCP头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。为了告知服务器已收到FIN为1的包，客户端会向服务器返回一个ACK号。此时，协议栈会等待应用程序调用read来读取数据。\n客户端发送FIN：客户端应用程序会调用close来结束数据收发操作，这时客户端的协议栈也会和服务器一样，生成一个FIN比特为1的TCP包，然后委托IP模块发送给服务器。\n服务端返回ACK号。删除套接字通讯结束之后，套接字会等待一段时间(一般为几分钟)之后删除，以防止误操作。误操作举例：假设当前是客户端先发起了断开操作，那么最后服务端发送FIN之后，正在等待ACK号返回。此时，客户端收到FIN之后立马删除了套接字，且套接字的端口也会释放，但是ACK回传的时候丢失了。那服务端会重传FIN消息，此时之前套接字的端口被其他套接字使用了，那这个FIN就会发到新创建的套接字上，于是断开操作又开始了，造成误操作。\n\n数据收发小结\nIP与以太网的包收发操作包的组成包由头部(目的地址等控制信息)、数据组成。其中头部包含：MAC头部、IP头部、TCP头部。MAC头部：用于以太网协议。IP协议会查找下一个路由器的以太网地址（MAC地址），并将这个地址写入MAC头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。IP头部：用于IP协议。发送方将包的目的地，也就是要访问的服务器的IP地址写入IP头部中。这样一来，我们就知道这个包应该发往哪里，IP协议就可以根据这一地址查找包的传输方向，从而找到下一个路由器的位置。\n包的收发概述TCP在数据块前面增加TCP头部之后委托IP模块发送包，IP模块添加IP头部、MAC头部之后再转交给网卡进行发送。\nIP头部IP模块的接收方IP地址是由TCP从应用程序获取的，而发送方的IP地址(网卡的IP)需要从路由表查询得到，我们可以通过route print命令来显示电脑的路由表。协议号：TCP为06，UDP为17。IP头部其他参数，可参考下面截图：\nMAC头部MAC头部的作用：以太网在判断网络包目的地时和TCP/IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个用的。上一步在路由表中获取到了IP，但是MAC地址是不知道的，这个时候需要拿IP换MAC，可以使用ARP查询MAC地址，其原理是使用广播把包发给统一子网的所有设备，对应设备会响应MAC。同时ARP也使用了缓存来提高查询效率（电脑上可以输入arp命令查询arp缓存）。以下为MAC头部的参数截图：\n转化成光、电信号发出IP模块生成的数字信息无法直接传输，需用通过网卡转化成光、电信号进行传输。\n\n网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC模块发送发送包的命令。\nMAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。\n\n报头用来测定时机，SFD用来确定帧的起始位置，末尾的FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串32比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。\n\n网卡的MAC模块生成通用信号，然后由PHY（MAU）模块转换成可在网线中传输的格式，并通过网线发送出去。同时，PHY（MAU）模块需要监控接收线路中有没有信号进来，避免信号碰撞。接收返回包PHY （MAU）模块会将信号转换成通用格式并发送给MAC模块，MAC模块再从头开始将信号转换为数字信息，并存放到缓冲区中。当到达信号的末尾时，还需要检查FCS。FCS校验没有问题：MAC头部中接收方MAC地址与网卡在初始化时分配给自己的MAC地址是否一致，如果不一致则直接丢弃，一致则将包放到缓存区。接着网卡需要通知计算机来取这个包，此时需要使用中断机制。中断机制：网卡在安装的时候在硬件中设置了中断号，在中断处理程序中则将硬件的中断号和相应的驱动程序绑定。执行中断操作的时候，网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到CPU。当产生中断信号时，CPU会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序，此时通过中断号直接拉起驱动程序从网卡的缓冲区中取出收到的包，并通过MAC头部中的以太类型字段判断协议的类型，网卡驱动就会把这样的包交给对应的协议栈。IP模块收到数据包之后，先判断是否有异常（例如IP是否是自己的地址），异常的话则弃包，并通过ICMP消息将错误告知发送方。无异常的话，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组。然后将完整的包转给TCP模块，TCP模块TCP头部中的接收方和发送方端口号来查找对应的套接字进行后续的操作。UAP协议的收发操作在这些无需重发数据，或者是重发了也没什么意义的情况下，使用UDP发送数据的效率会更高。DNS查询，音视频等可以使用UDP。UDP没有TCP的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上UDP头部，然后交给IP进行发送就可以了。接收也很简单，只要根据IP头部中的接收方和发送方IP地址，以及UDP头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。以下为UDP头部：\n\n集线器、交换机和路由器目前家庭路由器包含了集线器和交换机的功能，此处我们分开作为了解。\n集线器双绞线抑制噪声产生噪声的原因是周围的电磁波影响。主要来自两个方面：\n\n由电机、荧光灯、CRT显示器等设备泄漏出来的电磁波，这种电磁波来自网线之外的其他设备。信号线是用金属做成的，当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流，这种电流会导致波形发生失真。双绞线为螺旋形，其中两根信号线中产生的噪声电流方向就会相反，从而使得噪声电流相互抵消，噪声就得到了抑制。\n\n串扰：电流流过时就会向周围发出电磁波，这些电磁波对于其他信号线来说就成了噪声。调整每一对信号线的扭绞间隔（节距），由于正负信号线产生的噪声影响是相反的，所以两者就会相互抵消。\n工作方式集线器原封不动地将信号广播出去，所有接入设备均收到信号，通过MAC判断是否弃包。集线器于网卡需要交叉接线，MDI就是对RJ-45接口和信号收发模块进行直连接线，而MDI-X则是交叉接线。\n交换机工作原理交换机根据MAC地址表进行转发。MAC地址表主要包含两个信息，一个是设备的MAC地址，另一个是该设备连接在交换机的哪个端口上。相较于集线器的直接转发广播信号，交换机会先解包。PHY（MAU）模块以MDI-X模式进行连接，信号从网线进入PHY（MAU）后转化为通用格式，传递给MAC模块（此处的MAC模块不具有MAC地址），MAC模块将信号转换为数字信息，然后通过包末尾的FCS校验错误，如果没有问题则存放到缓冲区中。之后根据MAC地址表查找需要转发的端口。\nMAC地址表维护\n添加：收到包时，将发送方MAC地址以及其输入端口的号码写入MAC地址表中。意思是，某一个端口连接的设备发包经过交换机，交换机则将对应的MAC地址和端口记录下来了。\n\n删除：为了防止设备移动时产生问题，导致信号被转发到已删除设备的端口上，隔一段事件就会删除记录（几分钟）。\n特殊操作以上MAC地址表的维护产生一个疑问？如果MAC地址表中没有对应的MAC和端口信息，那信号是否就无法转发了？答案肯定不是，如果没有维护的话，交换机会像集线器一样将信号广播到所有端口。\n全双工模式可以同时进行发送和接收集线器犹豫是广播信号，因此不具备全双工的能力，会产生信号碰撞。使用双绞线时，发送和接收的信号线是各自独立的[插图]，因此在双绞线中信号不会发生碰撞。网线连接的另一端，即交换机端口和网卡的PHY （MAU）模块以及MAC模块，其内部发送和接收电路也是各自独立的，信号也不会发生碰撞。因此交换机的全双工模式可以同时发送和接收信号。\n自动协商：确定最优的传输速率在双绞线以太网规范最初制定的时候，只规定了按一定间隔发送脉冲信号，这种信号只能用来确认网络是否正常。后来，人们又设计出了具有特定排列的脉冲信号，通过这种信号可以将自身的状态告知对方。自动协商功能就利用了这样的脉冲信号，即通过这种信号将自己能够支持的工作模式[插图]和传输速率相互告知对方，并从中选择一个最优的组合。\n交换机可同时执行多个转发操作交换机只将包转发到具有特定MAC地址的设备连接的端口，其他端口都是空闲的，因此其他端口也可以进行包的转发。\n路由器基本知识\n\n\n路由器是基于IP设计的，而交换机是基于以太网设计的\n\n路由器包括转发模块和端口模块两部分。转发模块负责判断包的转发目的地，端口模块负责包的收发操作。\n工作原理路由器在转发包时，首先会通过端口将发过来的包接收进来，这一步的工作过程取决于端口对应的通信技术。对于以太网端口来说，就是按照以太网规范进行工作，而无线局域网端口则按照无线局域网的规范工作，总之就是委托端口的硬件将包接收进来。接下来，转发模块会根据接收到的包的IP头部中记录的接收方IP地址，在路由表中进行查询，以此判断转发目标。然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去，也就是转发模块委托端口模块将包发送出去的意思。和交换机不同的是，路由器的各个端口都具有MAC地址和IP地址，是以实际的发送方或者接收方的身份来收发网络包的。\n路由表中的信息\n目标地址、子网掩码：用来展示网络号和主机号信息，路由器匹配转发目标时只进行网络号匹配，因此网络号越长匹配越精准。\n\n网关、接口：表示网络包的转发目标。根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络包交给接口列中指定的网络接口（即端口）[插图]，并转发到网关列中指定的IP地址。\n\n跃点计数：表示距离目标IP地址的距离是远还是近。这个数字越小，表示距离目的地越近；数字越大，表示距离目的地越远。\n路由器的包接收操作信号到达网线接口部分，其中的PHY（MAU）模块和MAC模块将信号转换为数字信息，然后通过包末尾的FCS进行错误校验，如果没问题则检查MAC头部中的接收方MAC地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。\n查询路由表确定输出端口接收包之后丢弃MAC头部，再IP头部中的内容进行包的转发操作。查询路由表判断转发目标的规则：\n\n\n\n根据网络号匹配，网络号匹配到且网络号越长的优先选择\n\n如果存在两条网络号长度相同的记录，则选择跃点计数小的\n\n如果没匹配到，则选择默认路由（0.0.0.0），转发到对应的网关（默认网关），此时会转发到互联网接入路由器。\n\n如果没有默认路由且没匹配到，则直接丢弃这个包，并通过ICMP消息告知发送方。此时不能像交换机一样广播，因为路由器的工作环境是互联网，会造成网络拥塞。\n包的有效期从路由表中查找到转发目标之后，网络包就会被转交给输出端口发送出去。再次之前要刷新IP头部信息，其中包的有效期需要刷新，避免包转发进入死循环。TTL（Time to Live，生存时间）字段表示包的有效期，包每经过一个路由器的转发，这个值就会减1，当这个值变成0时，就表示超过了有效期，这个包就会被丢弃。发送方在发送包时会将TTL设为64或128。\n通过分片功能拆分大网络包包超大的情况：\n\n不同的线路和局域网类型各自能传输的最大包长度也不同，因此输出端口的最大包长度可能会小于输入端口\n\n添加了一些头部数据而导致包的实际长度发生变化，ADSL、FTTH等宽带接入技术中使用的PPPoE协议就属于这种情况\n\n\n判断分片的流程：\n\n获取端口的MTU，看包是否超大\n如果超过了MTU，则看IP头部中的标志字段是否支持分片，不支持则直接弃包并通过ICMP消息通知发送方。\n支持分片，则进行分片。每一份上加入IP头部，大部分和之前IP头部一致，但要加入分片信息。路由器的发送操作和计算机相同其基本过程和协议栈中的IP模块发送包的过程是相同的，即在包前面加上MAC头部。其中MAC头部的MAC地址需要根据IP转化而来。转发目标的IP获取到之后，路由器通过ARP查询获取到MAC地址即为接收方的MAC地址。发送方的MAC地址是端口的MAC地址。补充其他信息之后，网络包转电信号通过端口发出。路由器判断下一个转发目标的方法如下：\n\n\n如果路由表的网关列内容为IP地址，则该地址就是下一个转发目标。\n如果路由表的网关列内容为空，则IP头部中的接收方IP地址就是下一个转发目标。路由器的附加功能地址转化\n\n\n目的\n\n入网设备太多，公网IP不够分了，为了解决这个问题，将内网的设备分配私有地址，路由器做地址转化完成通信。私有地址如下：\n10.0.0.0~10.255.255.255172.16.0.0~172.16.255.255192.168.0.0~192.168.255.255\n\n\n原理\n\n地址转换的基本原理是在转发网络包时对IP头部中的IP地址和端口号进行改写。主要依赖于地址和端口对应表（包含：共有地址、端口号、私有地址、端口号）。TCP连接操作的第一个包被转发到互联网时，将发送方IP地址从私有地址改写成公有地址，端口号从空闲的端口中随机选择一个，之后包被发到互联网。在后面的包收发过程中，地址转换设备需要根据对应表查找私有地址和公有地址的对应关系，再改写地址和端口号之后进行转发。当数据收发结束，进入断开阶段，访问互联网的操作全部完成后，对应表中的记录就会被删除。\n\n从互联网访问共公司内网\n\n默认无法从互联网访问内网，是因为对应表里没有相应的记录，那么我们只要事先手动添加这样的记录就可以了。将私有地址和端口以及公有地址和对应固定端口写道对应表里面，则互联网可以访问对应共有地址和对应端口来访问内网。\n包过滤包过滤就是在对包进行转发时，根据MAC头部、IP头部、TCP头部的内容，按照事先设置好的规则决定是转发这个包，还是丢弃这个包。我们通常说的防火墙设备或软件，大多数都是利用这一机制来防止非法入侵的。\n接入网和网络运营商互联网的基本结构和家庭、公司网络是相同的，但是距离和维护方式不同是两个重要的不同点。\nADSL接入网ADSL接入线路如下图：具体步骤如下图：\nADSL Modem将包拆分成信元首先，互联网接入路由器会在网络包前面加上MAC头部、PPPoE头部、PPP头部总共3种头部，然后发送给ADSL Modem。然后，ADSL Modem会把包拆分成很多小格子，每一个小格子称为一个信元。信元是一个非常小的数据块，开头是有5个字节的头部，后面是48个字节的数据，用于一种叫作ATM的通信技术。转化成信元之后，再转换成电信号发送给分离器。\nADSL将信元“调制”成信号ADSL Modem采用了一种用圆滑波形（正弦波）对信号进行合成来表示0和1的技术，这种技术称为调制。调制有很多方式，ADSL采用的调制方式是振幅调制（ASK）和相位调制（PSK）相结合的正交振幅调制（QAM）方式。\n\n振幅调制：信号振幅的大小来对应0和1\n相位调制：根据信号的相位来对应0和1\n\n使用正交振幅调制的方式可以用一个波表示更多的比特，从而提高传输速率。正交振幅调制中，通过增加振幅和相位的级别，就可以增加能表示的比特数。\nADSL通过使用多个波来提高速率不同频率的波可以合成，也可以用滤波器从合成的波中分离出某个特定频率的波。因此，我们可以使用多个频率合成的波来传输信号，这样一来，能够表示的比特数就可以成倍提高了。ADSL就是利用了这一性质，通过多个波增加能表示的比特数来提高速率。当Modem通电后，会发送测试信号，并根据信号的接收情况判断使用的频段数量和每个频段的比特数，这个过程称为训练（握手）。\n分离器的作用\n信号从用户端发出\n\n电话和ADSL信号只是同时流到一条线路上而已，分离器实际上并没有做什么事。\n\n信后从电话线传入\n\n过滤掉了ADSL使用的高频信号，使电话信号传入电话机。ADSL Modem内部已经具备将ADSL频率外的信号过滤掉的功能，因此不需要在分离器进行过滤。\n从用户到电话局\n从分离器通过室内电话线，到达大楼的IDF(Intermediate Distribution Frame，中间配线盘)和MDF(Main Distribution Frame，主配线盘，总配线架)\n\n到达保安器，防止雷电等情况下电话线中产生过大电流的一种保护装置，内部有保险丝。\n\n信号会进入电线杆上架设的电话电缆\n\n入地后进入电话局：集中埋设电缆的地方就形成了一条地道，这部分称为电缆隧道\n通过DSLAM到达BASDSLAM通过读取信号波形，根据振幅和相位判断对应的比特值，将信号还原成数字信息。DSLAM一般不用以太网接口，而是用ATM接口，和后方路由器收发数据时使用的是原始网络包拆分后的ATM信元形式。BAS的操作：通过ATM接口将ATM信元转化成原始包；丢弃MAC头部和PPPoE头部，取出PPP头部以及后面的数据；BAS会在包的前面加上隧道专用头部，并发送到隧道的出口；网络包会到达隧道出口的隧道专用路由器；在这里隧道头部会被去掉，IP包会被取出，并被转发到互联网内部。\n光纤接入网（FTTH）基本知识它是由一种双层结构的纤维状透明材质（玻璃和塑料）构成的，通过在里面的纤芯中传导光信号来传输数字信息。电信号转光信号：电信号输入LED、激光二极管等光源后，这些光源就会根据信号电压的变化发光，高电压发光亮，低电压发光暗。光信号转电信号：接收端有可以感应光线的光敏元件，光敏元件可以根据光的亮度产生不同的电压。\n单模与多模光纤单模：较细(8～10 μm)，入射角很小的光线才能进入，只能传导一条光线。对于光源和光敏元件的性能要求就较高，但信号的失真会比较小。双模：较粗(50 μm或62.5 μm)，入射角比较大的光也可以进入，可以传导多条光线。可以降低光源和光敏元件的价格，但远距离失真较大。\n通过光纤分路来降低成本\n直连方式\n\n\n用一根光纤直接从用户端连接到最近的电话局，用户端的光纤收发器将以太网的电信号转换成光信号。此方式不需要再拆分信元，直接将以太网包转换成光信号，然后光信号通过连接到光纤收发器的光纤直接到达BAS前面的多路光纤收发器。为了区分上行和下行信号的光，采用不同波长的光，混合后可以通过棱镜原理进行分离。像这样在一条光纤中使用不同的波长传输多个光信号的方式叫作波分复用。\n\n分路方式\n\n在用户附近的电线杆上安装一个名为分光器的设备，通过这个设备让光纤分路，同时连接多个用户。用户端不使用光纤收发器，而是使用一个叫作ONU的设备，它将以太网的电信号转换成光信号之后，会到达BAS前面的一个叫作OLT的设备。为了避免在分光器发生信号碰撞，OLT和ONU中具备通过调整信号收发时机来避免碰撞。\n接入网中使用的PPP和隧道用户认证和配置下发\n\n用户向运营商的接入点拨打电话\n\n输入用户名和密码进行登录操作\n\n用户名和密码通过RADIUS(Remote Authentication Dial-in User Service，远程认证拨号用户服务)协议从RAS(Remote Access Server，远程访问服务器)发送到认证服务器\n\n认证服务器校验无误后返回IP地址等配置信息，下发给用户\n\n用户的计算机根据这些信息配置IP地址等参数，完成TCP/IP收发网络包的准备工作，接下来就可以发送TCP/IP包了\n在以太网上传输PPP消息-PPPoEPPP协议中没有定义以太网中的报头和FCS等元素，也没有定义信号的格式，因此无法直接将PPP消息转换成信号来发送。这里需要将PPP消息包装一层，因此使用PPPoE将PPP消息装入以太网包进行传输。\n通过隧道将网络包发送给运营商BAS除了作为用户认证的窗口之外，还可以使用隧道方式来传输网络包。隧道有两种实现方式：\n\n使用TCP连接：在网络上的两台隧道路由器之间建立TCP连接，然后将连接两端的套接字当作是路由器的端口，并从这个端口来收发数据。\n\n基于封装（encapsulation）实现：将包含头部在内的整个包装入另一个包中传输到隧道的另一端。\n接入网的整体工作过程\n用户端的互联网接入路由器配置运营商分配的用户名和密码\n\n接入路由器会根据PPPoE的发现机制来寻找BAS，类似于ARP广播\n\n用户名和密码发送给BAS，两种方式：1. 将密码进行加密的CHAP(Challenge Handshake Authentication Protocol, 挑战握手认证协议)，推荐方式；2. 不加密的PAP(Password Authentication Protocol, 密码验证协议)。\n\nBAS向用户下发TCP/IP配置信息(分配给上网设备的IP地址、DNS服务器的IP地址以及默认网关的IP地址)。\n\n客户端发送包。包含MAC头部（接收方MAC地址填写通过PPPoE发现机制查询到的BAS的MAC地址，发送方MAC地址填写互联网接入路由器的BAS端的端口的MAC地址）、PPPoE头部、PPP头部。\n\n包到达BAS，去掉MAC头部和PPPoE头部，然后用隧道机制将包发送给网络运营商的路由器。\n除PPPoE之外的其他方式PPPoAPoint-to-Point Protocol over ATM，该方式不添加MAC头部和PPPoE头部，而是直接将包装入信元中。无法通过以太网传输，但是MTU不会变小，传输效率会高点。DHCPDynamic Host Configuration Protocol, 动态主机配置协议。常用于通过公司网络向客户端计算机下发TCP/IP配置信息，不需要用户名和密码，不需要添加额外的PPP头部，将以太网包直接转换成ADSL信号发送给DSLAM。\n网络运营商的内部从接入网出来后，网络包会到达网络运营商路由器，之后会到达互联网内部。有以下两种设备：POPPoint of Presense, 接入点。包括各种类型的路由器对应连接不同得接入网：专线接入、拨号接入、PPPoE、PPPoA等。NOCNework Operation Center，网络运行中心。从POP传来的网络包都会集中到这里，并从这里被转发到离目的地更近的POP，或者是转发到其他的运营商。NOC和POP并没有非常严格的界定，可以简单地认为，NOC就是规模扩大后的POP。\n跨越运营商的网络包运营商之间的路由信息交换路由器自动完成路由信息交换的机制称为BGP(Border Gateway Protocol，边界网关协议)。分为两类：一类是将互联网中的路由全部告知对方，叫做转接。这种方式不仅会告知自己的路由信息，还会告知运营商后面的其他运营商的路由信息。另一种类型是两个运营商之间仅将与各自网络相关的路由信息告知对方。这样，只有双方之间的网络可以互相收发网络包，这种方式称为非转接，也叫对等。\n与公司网络中自动更新路由表机制的区别公司中使用的方式是寻找与目的地之间的最短路由，并按照最短路由来转发包。运营商除了最短路由外，还要根据客户购买的线路等信息做出限制，选择最优路由。\nIXInternet eXchange，互联网交换中心，通过各运营商连接到中心设备的方式来减少线路数量。IX的核心是具有大量高速以太网端口的二层交换机。二层交换机的基本原理和一般交换机相同，可以认为IX的核心就是大型的、高速的交换机。各个运营商的路由器通过POP或者通信线路连接到IX核心交换机上。\n\n\n服务器端的局域网Web服务器的部署地点\n部署在公司内网，在Web服务器之前增加防火墙\n\n把服务器放在网络运营商等管理的数据中心里，或者直接租用运营商提供的服务器。数据中心是与运营商核心部分NOC直接连接的，或者是与运营商之间的枢纽IX直接连接的。因此，放到数据中心部署高速可靠。\n防火墙防火墙可以分为包过滤、应用层网关、电路层网关等方式，，但出于性能、价格、易用性等因素，现在最为普及的是包过滤方式。包过滤的原理是：根据接收方IP地址、发送方IP地址、接收方端口号、发送方端口号、控制位等信息来判断是否允许某个包通过，因此会读取IP头部、TCP(UDP)头部等头部相关字段的信息。包过滤的几种场景解析：\n\n互联网发往Web服务器的包：可以读取接收方的IP，为Web服务器IP的包允许通过；另外也可以增加发送方的IP限制。\n\n通过端口号限定应用程序：可以读取接收方的端口限制包通过，这样可以防止其他应用程序被非法访问。例如可以限制只允许访问Web服务器的80端口。\n\n通过控制位判断连接方向：假如有个场景需要限制Web服务器任意访问互联网，但是犹豫TCP是双向收发网络包的，因此不能直接过滤掉对应端口的包。可以通过TCP头部信息判断，禁用掉TCP控制位中SYN为1、ACK为0的包，这样Web服务器无法连接互联网了，但是TCP响应的报不会有SYN为1的情况，因此可以正常通过。\n负载均衡首先要用负载均衡器的IP地址代替Web服务器的实际地址注册到DNS服务器上，负载均衡器来判断要转发到哪台Web服务器。如何判断：1. 可以向Web服务器发送测试包，根据响应所需的时间来判断负载状况；2. 根据事先设置的服务器性能指数，按比例来分配请求。使用负载均衡器分配访问时很重要的时需要判断是否多页访问，来自一个客户端的应该在一个周期内都是分到同一台服务器了，但HTTP访问都是独立的，因此需要标识，一般可以通过增加请求头来作为区分，例如增加Cookie。\n使用缓存服务器分担负载除了使用多台Web服务器外，也可以将整个系统按功能分成不同的服务器，如Web服务器、数据库服务器、缓存服务器。\n缓存服务器的工作过程缓存服务器会添加一个If-Modified-Since头部字段并将请求转发给Web服务器，询问Web服务器用户请求的数据是否已经发生变化。Web服务器会根据If-Modified-Since的值与服务器上的页面数据的最后更新时间进行比较，如果在指定时间内数据没有变化，则返回304即可，缓存服务器将缓存返回给客户端。如果有更新则返回更新的数据，然后缓存服务器加上Via字段发送给客户端，同时将数据保存在缓存中。\n正向代理正向代理将代理服务器（如缓存服务器）放到客户端一侧。在使用正向代理时，一般需要在浏览器的设置窗口中的“代理服务器”一栏中填写正向代理的IP地址，浏览器发送请求消息的过程也会发生相应的变化。\n反向代理可以通过将请求消息中的URI中的目录名与Web服务器进行关联，使得代理能够转发一般的不包含完整网址的请求消息。nginx反向代理就是这样的逻辑。\n透明代理原理：缓存服务器判断转发目标的方法还有一种，那就是查看请求消息的包头部。因为包的IP头部中包含接收方IP地址(也可以是读取http头部的Host字段)，只要知道了这个地址，就知道用户要访问哪台服务器了。过程：我们必须将透明代理放在请求消息从浏览器传输到Web服务器的路径中，当消息经过时进行拦截。因此，可以放置到接入网的入口处。\n内容分发服务定义内容分发服务：CDS（Content Delivery Service），现在常叫做CDN（Content Delivery Network或Content Distribution Network）。CDSP：Content Delivery Service Provider，内容分发服务运营商。\n原理CDSP会与主要的供应商签约，并部署很多台缓存服务器，然后CDSP会与Web服务器运营者签约。只要Web服务器与缓存服务器建立关联，那么当客户端访问Web服务器时，实际上就是在访问CDSP的缓存服务器了。\n寻找最近的缓存服务器\n通过DNS查询寻找\n\n\n首先服务端的DNS服务器从缓存服务器部署地点的路由器收集路由信息，然后根据路由表查询到各缓存服务器到客户端DNS服务器的路由信息。根据该路由信息中经过了多少运营商来估算远近，最后返回最近的服务器的IP地址给客户端DNS服务器。\n\n通过重定向服务器分配访问目标\n将重定向服务器的IP注册到Web服务器端的DNS服务器上\n重定向服务器收集了来自各个路由器的路由信息\n根据路由信息找到最近的缓存服务器，并将缓存服务器地址写到Location字段返回给客户端（这就是302重定向）\n客户端的请求重定向到最近的缓存服务器，这才是请求的真正目标\n\n\n\n缺点：增加了HTTP消息的交互次数，开销增大；优点：相较于通过DNS查询，这里查找最近的缓存服务器使用的是HTTP请求头中的IP，因此精度更高。\n缓存的更新方法会影响性能数据更新后第一次访问的时候缓存服务器必然回去取原始数据，然后刷新缓存，这样增大的开销。因此一般内存分发服务的缓存服务器具有这样的功能，当Web服务器在原始数据发生更新时，立即通知缓存服务器，使得缓存服务器上的数据一直保持最新状态，这样第一次访问就有缓存效果。\n请求到达Web服务器，响应返回浏览器服务器概览服务器包含两个模块：等待连接模块，负责与客户端通信的模块。服务端的收发过程如下：（1）创建套接字（创建套接字阶段）（2-1）将套接字设置为等待连接状态（等待连接阶段）（2-2）接受连接（接受连接阶段）（3）收发数据（收发阶段）（4）断开管道并删除套接字（断开阶段）\n服务器端的套接字和端口号\n套接字的创建和连接过程\n协议栈调用socket创建套接字\n协议栈调用bind将端口号写入套接字中，例如Web服务器使用80端口\n协议栈调用listen向套接字写入等待连接状态这一控制信息，套接字开始等待来自客户端的连接网络包\n协议栈调用accept来接受连接。这是还没有包到来，一般来说服务器端都是处于等待包到达的状态，这时应用程序会暂停运行。客户端的包到达，返回响应包并开始接受连接操作。协议栈会给等待连接的套接字复制一个副本，然后将连接对象等控制信息写入新的套接字中。\naccept结束之后，等待连接的过程也就结束了，这时等待连接模块会启动客户端通信模块，然后将连接好的新套接字转交给客户端通信模块。\n\n\n复制新套接字的作用\n\n服务端是一对多的场景，需要复制新套接字用来传输数据，而旧的套接字要继续等待新的连接。且要保持两端的套接字正常连接，需要复制的套接字具有相同的端口。但是一个端口无法识别多个套接字，因此服务端的协议栈需要四个信息（客户端IP地址、客户端端口号、服务器IP地址、服务器端口号）来判断连接哪个套接字。但是套接字的描述符依然需要，因为：1. 等待连接的套接字中没有客户端IP地址和端口号；使用描述符这一种信息比较简单。出于这两个原因，应用程序和协议栈之间是使用描述符来指代套接字的。\n服务器的接收操作网卡将接收到的信号转换成数字信息网卡的MAC模块将网络包从信号还原为数字信息，校验FCS并存入缓冲区。之后网卡通过中断将网络包到达的事件通知给CPU，CPU暂停当前工作并切换到网卡的任务。网卡驱动会根据MAC头部判断协议类型，并将包交给相应的协议栈。\nIP模块的接收操作到达协议栈之后IP模块开始工作，检查IP头部，（1）判断是不是发给自己的；（2）判断网络包是否经过分片；（3）将包转交给TCP模块或UDP模块\nTCP模块如何处理连接包如果收到的是发起连接的包，则TCP模块会（1）确认TCP头部的控制位SYN; （2）检查接收方端口号；（3）为相应的等待连接套接字复制一个新的副本；（4）记录发送方IP地址和端口号等信息。\nTCP模块如何处理数据包收到数据包时，TCP模块会（1）根据收到的包的发送方IP地址、发送方端口号、接收方IP地址、接收方端口号找到相对应的套接字；（2）将数据块拼合起来并保存在接收缓冲区中；（3）向客户端返回ACK。\nTCP模块的断开操作断开操作可以由客户端或服务器任何一方发起，具体的顺序是由应用层协议决定的。在HTTP1.0中，是服务器先发起断开操作，HTTP1.1中，是客户端先发起断开操作。和之前在协议和网卡中介绍的断开操作一样，这里进行“四次挥手”：调用Socket库的close, TCP模块会生成一个控制位FIN为1的TCP头部，并委托IP模块发送给客户端。当客户端收到这个包之后，会返回一个ACK号。接下来客户端调用close，生成一个FIN为1的TCP头部发给服务器，服务器再返回ACK号，这时断开操作就完成了。\nWeb服务器程序解释请求消息并作出响应将请求的URI转换为实际的文件名URI访问的目录和实际服务器的文件目录并不会对应，这样可以控制客户端目录的访问。因此，需要设置好目录改写的规则，当URI中的路径符合改写规则时，就可以将URI中的文件名改写成其他的文件名进行访问。\n运行CGI程序目前接触到的项目中，基本不会使用CGI程序，这里只是做个介绍。Web服务器会检查URI指定的文件名，将．cgi、.php等扩展名的文件设置为程序，当遇到这些文件时，Web服务器就会将它们作为程序来对待。应用程序输出的数据一般来说会嵌入到HTML文档中，因此Web服务器可以直接将其作为响应消息返回给客户端。\nWeb服务器的访问控制访问控制规则主要有以下3种：客户端IP地址、客户端域名、用户名和密码。\n返回响应消息首先，Web服务器调用Socket库的write，将响应消息交给协议栈。并将对应套接字的描述符给到协议栈即可知道通信状态。协议栈会将数据拆分成多个网络包，然后加上头部发送出去。这些包中包含接收方客户端的地址，它们将经过交换机和路由器的转发，通过互联网最终到达客户端。\n浏览器接收响应消息并显示内容浏览器根据响应头中的Content-Type来渲染指定格式的文件，有时也会结合文件扩展名(例如.html)来展示。\n网络包的路程\n","categories":["网络"],"tags":["网络","TCP/IP"]},{"title":"Vue多项目打包","url":"/2022/04/26/Vue%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/","content":"导语有时业务中遇到这样的场景，多个项目有很多共用的逻辑，后面又是独立部署。例如PC端和移动端，UI完全不同，但逻辑有很多能复用，但是这里我们计划是分开部署。这里仅说有这种场景，大致痛点如下。\n\n分两个项目，则代码维护两套，复用逻辑要copy\n合成一个项目：路由区分或者多页配置。这种上线部署的时候又会互相影响，部署则都刷新。且目录在一起，可扒取到另外一个项目的资源。\n\n为此，需要一种方式，能代码共仓以复用逻辑，但是打包部署可以独立。\n实现实现该需求，有如下考虑：\n\n既然可独立打包，那这里考虑打包的时候传参\n多项目在打包配置上可能存在差异，可针对不同项目的灵活配置是必要的\n涉及到部署，那部署的情况也是要考虑到的约定为方便表述，这里做个约定，我们的项目分为mobile、pc两个。\n\n打包传参的处理命令行打包，做以下区分：\n# mobile# 本地运行npm run dev -- --page=mobile# 打包npm run build -- --page=mobile# pc# 本地运行npm run dev -- --page=pc# 打包npm run build -- --page=pc\n以上是参数的传入，接着解析参数，做成通用的，形如 --key=value的都可以被解析。这里我们将参数写成 VUE_APP_PAGE的形式，这样项目代码逻辑中也可以使用这个参数，以便处理复用代码要区分不同项目的场景。同时，这里实现getEnv函数，以便在其他打包逻辑中可以获取到自己想要的参数。\n// 使用正则解析参数function handleEnv() &#123;  const reg = /--(\\w+)=(.+)/;  const keysArr = process.argv.filter( e =&gt; reg.test(e));  keysArr.forEach( varStr =&gt; &#123;    const varArr = varStr.match(reg);    process.env[`VUE_APP_$&#123;varArr[1].toLocaleUpperCase()&#125;`] = varArr[2];  &#125;);&#125;// 获取对应的参数，如果key不传则返回所有的，这里做一次缓存代理，避免重复解析const getEnv = (() =&gt; &#123;  let isHandleEnv = false;  return (key) =&gt; &#123;    if (!isHandleEnv) &#123;      handleEnv();      isHandleEnv = true;    &#125;    return key ? process.env[key] :process.env;  &#125;&#125;)();\n以上已经拿到了参数，接下来是参数用起来\n处理打包配置这里总的逻辑还是使用了pages配置项，不过每次只打包了一个page。首先说明文件，为了方便自定义配置，这里我们拆分文件：\n\ncommon.config.js用来存储多个项目公用的配置\ncustom.config.js用来存储不同项目自定义的配置\nvue.config.js合并common、custom的配置，生成最终的打包配置\n\ncommon.config.js的配置举例如下：\nmodule.exports = &#123;  publicPath: &#x27;./&#x27;,  assetsDir: &#x27;static&#x27;,  productionSourceMap: false,  lintOnSave: true,  devServer: &#123;    host: &#x27;0.0.0.0&#x27;,    port: 3000,    hotOnly: true,     proxy: &#123;      &#x27;/&#x27;: &#123;        ws: true,        target: &#x27;http://test.myproject.com/&#x27;,        changeOrigin: true,        secure: false,      &#125;,    &#125;  &#125;,  configureWebpack: config =&gt; &#123;    // 这里写自定义的webpack配置  &#125;,  chainWebpack(config) &#123;    // 这里我们设置了一下别名    config.resolve.alias      .set(&#x27;@pc&#x27;, resolve(&#x27;./src/pc&#x27;))      .set(&#x27;@mobile&#x27;, resolve(&#x27;./src/mobile&#x27;))      .set(&#x27;@src&#x27;, resolve(&#x27;./src&#x27;))  &#125;&#125;\ncustom.config.js的配置举例如下：\nmodule.exports = &#123;  // 移动端的自定义配置  mobile: &#123;    // page的自定义配置，后面会和默认的配置合并    page: &#123;      title: &#x27;mobile title&#x27;    &#125;  &#125;,  // pc端的自定义配置  pc: &#123;    page: &#123;      title: &#x27;pc title&#x27;    &#125;,    chainWebpack(config) &#123;      // 这里我们设置了一下pc端的svg打包，但是移动端不需要，因此是在自定义配置      config.module      .rule(&#x27;svg&#x27;)      .exclude.add(resolve(&#x27;src/platform/icons&#x27;))      .end()    config.module      .rule(&#x27;icons&#x27;)      .test(/\\.svg$/)      .include.add(resolve(&#x27;src/platform/icons&#x27;))      .end()      .use(&#x27;svg-sprite-loader&#x27;)      .loader(&#x27;svg-sprite-loader&#x27;)      .options(&#123;        symbolId: &#x27;icon-[name]&#x27;      &#125;)      .end()    &#125;  &#125;,&#125;\nvue.config.js的配置，这块是重点，会结合上面两个配置生成最终的配置。\nconst path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);// 导入以上两份配置const commonConfig = require(&#x27;./common.config&#x27;)const customConfig = require(&#x27;./custom.config&#x27;)const &#123; getEnv &#125; = require(&#x27;./utils&#x27;);// 获取到了当前的page参数let pageName = getEnv(&#x27;VUE_APP_PAGE&#x27;);// 我们将pc和mobile两个项目放到了 `src/pages` 目录下const dirs = fs.readdirSync(path.join(__dirname, &#x27;src/pages&#x27;))// 异常处理，当pageName没匹配到时默认做pc处理if (!dirs.includes(pageName)) &#123;  console.warn(`$&#123;pageName&#125; is not exist`);  pageName = &#x27;pc&#x27;;&#125;// 获取对应页面的自定义配置，这里page参数单独拿出作为后面pages配置的合并，其他参数走通用的合并const &#123; page, ...pageCustomConfig &#125; = customConfig[pageName] || &#123; page: &#123;&#125; &#125;;// 根据pageName生成对应的pages配置，这里合并上一步的page参数，目的是当两个项目index.html使用一份的时候，可以不放置两个html，而是使用一个，但是可以通过page参数指定title参数区分const defaultPageConfig = &#123;  pages: &#123;    [pageName]: &#123;      entry: `src/$&#123;pageName&#125;/main.js`,      template: `public/$&#123;pageName&#125;.html`,      filename: &#x27;index.html&#x27;,      ...page    &#125;  &#125;,  // ☆ 这里是关键，打包到dist下面对应项目的子目录，这样可以分开打包两个项目，互不影响  outputDir: `dist/$&#123;pageName&#125;`&#125;// 这里的config就是我们生成的基本配置啦，但是custom的配置还没处理const config = &#123;  ...baseConfig,  ...defaultPageConfig,&#125;// 遍历自定义配置pageCustomConfigfor (const key in pageCustomConfig) &#123;  if (Object.hasOwnProperty.call(pageCustomConfig, key)) &#123;    // 这里拿到的配置有可能是值、也有可能是函数(例如：chainWebpack)    const valueOrFunction = pageCustomConfig[key];    // 当自定义页面配置为函数时，默认会合并自定义配置和baseConfig中的配置。    if (valueOrFunction instanceof Function) &#123;      // 拿到了通用配置中相同项，做函数合并。      const baseFunction = config[key] || function() &#123;&#125;;      config[key] = function() &#123;        // 先调用自定义的配置的函数，如果返回true则代表自定义配置完全覆盖common配置，否则两者合并        const isReplaceBase = valueOrFunction.apply(null, arguments);        // 两者合并的情况，调用common中的配置        !isReplaceBase &amp;&amp; baseFunction.apply(null, arguments);      &#125;    &#125; else &#123;      // 不是函数，则直接覆盖      config[key] = valueOrFunction;    &#125;  &#125;&#125;module.exports = config;\n另外，有些情况可能仅在上面的自定义配置中无法完成，例如这里要修改postcss的配置完成移动端rem的配置，可以修改postcss.config.js\nconst &#123; getEnv &#125; = require(&#x27;./utils&#x27;)const plugins = &#123;  autoprefixer: &#123;&#125;,&#125;// 使用 getEnv 获取当前的page参数，仅在移动端设置rem转化if (getEnv(&#x27;VUE_APP_PAGE&#x27;) === &#x27;mobile&#x27;) &#123;  plugins[&#x27;postcss-pxtorem&#x27;] = &#123;    rootValue: 16,    propList: [&#x27;*&#x27;],    unitPrecision: 5,  &#125;&#125;module.exports = &#123;  plugins&#125;\npackage.json的修改以上就完成了自定义的打包，但是本地运行还要每次传参就比较麻烦，改下package.json让项目更好用。\n&#123;  &quot;scripts&quot;: &#123;    // 默认启动pc    &quot;dev&quot;: &quot;vue-cli-service serve&quot;,    // 启动移动端    &quot;dev:collection&quot;: &quot;npm run dev -- --page=mobile&quot;,    // 默认打包pc    &quot;build&quot;: &quot;vue-cli-service build&quot;,    // 两者一起打包    &quot;build:all&quot;: &quot;npm run build &amp;&amp; npm run build:mobile&quot;,    &quot;build:pc&quot;: &quot;vue-cli-service build&quot;,    // 单独打包移动端    &quot;build:mobile&quot;: &quot;npm run build -- --page=mobile&quot;,  &#125;&#125;\n部署完成以上打包之后，考虑下部署的事情。之前可能部署的方式是直接删除旧的前端包，部署新的。那现在情况不太一样了，pc、mobile都要部署则可以这么干，但是如果只是部署mobile，那之前前端包中的pc就不能删除，这里我们改写下部署的 bash脚本。可能你不是bash脚本，但是原理一样。\n#!/bin/bash# 指定项目目录名称PROJECT_DIR=my-test-project# 指定项目目录放置的地方BASE_DIR=/home/www# 解压比对的临时目录PROJECT_DIR_TEMP=$&#123;BASE_DIR&#125;/$&#123;PROJECT_DIR&#125;-temp# 项目的根目录PROJECT_ROOT_DIR=$&#123;BASE_DIR&#125;/$&#123;PROJECT_DIR&#125;# 处理部署的时候新建项目目录if [ ! -d $&#123;PROJECT_ROOT_DIR&#125; ];thenmkdir -p $&#123;PROJECT_ROOT_DIR&#125;fi# 创建临时目录if [ ! -d $&#123;PROJECT_DIR_TEMP&#125; ];thenmkdir -p $&#123;PROJECT_DIR_TEMP&#125;fi# 拷贝前端包到临时目录，并解压操作cp $&#123;PROJECT_DIR&#125;.zip $&#123;PROJECT_DIR_TEMP&#125;cd $&#123;PROJECT_DIR_TEMP&#125;unzip $&#123;PROJECT_DIR&#125;.ziprm $&#123;PROJECT_DIR&#125;.zip# 此处遍历前端包中的目录，有以下情况# 1. 有pc、mobile两个目录，则是两个项目一块部署，之前两个目录均删除# 2. 仅有一个目录，如仅有mobile目录，则只部署移动端，pc端代码不部署for file in $PROJECT_DIR_TEMP/*doif [ -d &quot;$file&quot; ]then  # 此处读取目录的名称，匹配最后一个 / 之后的名称  page_name=$&#123;file##*/&#125;  echo $page_name  # 如果在项目根目录下存在当前目录，则删除掉该旧目录  if [ -d &quot;$PROJECT_ROOT_DIR/$page_name&quot; ]  then    rm -r &quot;$PROJECT_ROOT_DIR/$page_name&quot;  fifidone# 删除之后将临时目录下解压的文件全部移到项目根目录mv $PROJECT_DIR_TEMP/* $PROJECT_ROOT_DIR# 删除临时目录rm -r $PROJECT_DIR_TEMP\n","categories":["前端"],"tags":["Vue"]}]