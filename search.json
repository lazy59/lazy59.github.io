[{"title":"hexo使用rsync部署填坑之路","url":"/2021/11/21/hexo%E4%BD%BF%E7%94%A8rsync%E9%83%A8%E7%BD%B2%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/","content":"hexo 可快速上手做出自己的博客网站，部署方式 也非常多。在部署到github的时候基本不会遇到什么问题，但是当选择使用rsync部署到阿里云ECS的时候，windows下部署的坑就一个个的出现了。\n遇到的问题首先看下官方的部署教程， 只有下面一小段内容：\n安装 hexo-deployer-rsync。\n$ npm install hexo-deployer-rsync --save\n修改配置\ndeploy:  type: rsync  host: &lt;host&gt;  user: &lt;user&gt;  root: &lt;root&gt;  port: [port]  delete: [true|false]  verbose: [true|false]  ignore_errors: [true|false]\nrsync不存在的报错直接运行 hexo d 之后就会报错了，有可能在powershell上面是乱码，git bash运行后出现以下报错：\nINFO  Validating configINFO  Deploying: rsync&#x27;rsync&#x27; is not recognized as an internal or external command,operable program or batch file.\n\nwindows默认没安装rsync，查找之后要安装cwrsync。然后去官网下载多个版本后出现了各种其他问题，这里我用5.5.0版本完成了后续操作。\n下载之后进行了如下操作：\n首先，下载的软件包解压到想放的位置，然后双击 cwrsync.cmd 开始安装，正常则会生成 home 目录，但是我这边没有生成(截图中是我后手动添加的)。\n\nok，先没管 home 目录，先将 bin 目录添加到环境变量，以便访问到 rsync.exe 文件。之后再来 hexo d 一次。好，出现了如下报错：\nINFO  Validating configINFO  Deploying: rsyncCould not create directory &#x27;/home/lazy5/.ssh&#x27;.Host key verification failed.rsync: connection unexpectedly closed (0 bytes received so far) [sender]rsync error: error in rsync protocol data stream (code 12) at io.c(226) [sender=3.1.2]\n\n上面报错那意思没找到ssh密钥存储的目录，奇怪的是我这边用户根目录下有.ssh目录，且服务器上也添加了对应公钥。而且这个目录很奇怪，/home这种目录应该指的linux下的目录结构吧。几番研究发现，这个版本的rsync调用的ssh并不是我们安装的，而是cwrsync的bin目录下的ssh.exe，那意思就是这个密钥目录可能不是指向用户目录的，而是cwrsync的安装目录。于是，在安装目录我新建了 /home/lazy5/.ssh 目录。\n同时双击 bin 目录下的 ssh-keygen.exe 文件，之后一路回车，则在 /home/lazy5/.ssh 目录下生成密钥对，目录如下：\n\n将生成的公钥添加到服务器对应用户的 authorized_keys 中，然后再部署一次试试。还是失败了，查看下面的 无权限报错\n无权限报错首先出现的是如下权限过高的问题：\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0770 for &#x27;/home/lazy5/.ssh/id_rsa&#x27; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;/home/lazy5/.ssh/id_rsa&quot;: bad permissionsPermission denied (publickey,gssapi-keyex,gssapi-with-mic).\n\n因此，我删除了 /home/lazy5/.ssh/id_rsa 除了所有者 lazy5 以外的权限。\n以上设置之后，权限过高的问题就没有了。理论上这样部署就没有了，但是在实际操作中还遇到了其他权限问题，具体截图没有了，列举如下：\n\ndeploy 配置使用的是 root ，导致访问被拒绝。这里建议新建一个用户用户rsync的操作，同时建议和本地windows电脑用户名一致，我这里是 lazy5，服务器上也新建了一个一样的用户名。\n部署报建立文件夹没权限的问题：由于新建的 lazy5 不在 root 组，而部署的目录属于 root 用户，chown 将目录权限改到 lazy5， 同时也可以把 lazy5 加到 root 组。\n服务器访问拒绝的其他权限问题：服务器ssh未开启公钥登录的方式，修改配置文件。\nvim /etc/ssh/sshd_config\n增加如下配置： PubkeyAuthentication yesPermitRootLogin yesPasswordAuthentication noRSAAuthentication yes\n重新加载，systemctl restart sshd\n\n\n\n成功上传之后域名访问403一切大功告成，访问网站出现了403，估计是权限的问题了。查看hexo目录下的文件权限如下：\nchmod 777 hexo -R 之后可以正常访问，但是每次部署后都需要登录服务器修改权限，这种方式肯定是不行的。那rsync为什么要改权限呢，依据是什么？前面说到了部署到服务器的文件是lazy5权限，那是不是文件访问的权限是不是也是直接用了本地文件权限。\n查看本地项目目录属性，权限中没有 Everyone，因此添加上去再说。\n重新部署后，终于权限正常了！\n后语以上就是 hexo 中使用 rsync 遇到坑的大致记录，其中由于填坑过程遗漏了很多记录，所以不一定全面，后续有再遇到会继续补充。另外由于坑太多，感觉这里直接 pm2 部署，在服务器上再 hexo generate 生成，估计也能达到一样的效果，后续可尝试并记录下。\n","categories":["服务器"],"tags":["hexo","ssh","部署"]},{"title":"shell学习记录","url":"/2022/05/11/shell%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"shell 常用于服务器上编译部署脚本、文件归档等场景。此文记录常用的语法，方便后续使用查找。\n变量常用系统变量$HOME、 $PWD、 $SHELL、 $USER 等 \n特殊变量\n$n\n\nn 为数字， $0 代表该脚本名称， $1-$9 代表第一到第九个参数， 十以上的参数， 十以上的参数需要用大括号包含， 如${10} \n\n$#\n\n获取所有输入参数个数， 常用于循环,判断参数的个数是否正确以及加强脚本的健壮性 \n\n$*、 $@代表命令行中所有的参数，$*把所有的参数看成一个整体 ，$@把每个参数区分对待\n$?\n\n最后一次执行的命令的返回状态。 如果这个变量的值为 0， 证明上一个命令正确执行； 如果这个变量的值为非 0（具体是哪个数， 由命令自己来决定） ， 则证明上一个命令执行不正确 \n字符串处理\n获取字符串长度\n\n$&#123;#string&#125;  获取字符串string的长度$&#123;string:1:4&#125;  截取字符串，从第2个字符开始，截取长度为4\n\n查找字符串\n\n查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)\nstring=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io`  # 输出 4\n数组数组的定义用小括号包裹，数组的值之间用空格区隔\narray_name=(value0 value1 value2 value3)# 单独定义也可以array_name[0]=value0array_name[1]=value1array_name[n]=valuen\n数组的读取$&#123;array_name[n]&#125; 获取数组的某一项$&#123;array_name[@]&#125; 获取数组所有参数$&#123;#array_name[@]&#125;、$&#123;#array_name[*]&#125; 获取数组元素的个数\n运算符$((运算式))  或  $[运算式] \n关系运算符\n\n\n-eq\n检测两个数是否相等，相等返回 true。\n\n\n\n-ne\n检测两个数是否不相等，不相等返回 true。\n\n\n-gt\n检测左边的数是否大于右边的，如果是，则返回 true。\n\n\n-lt\n检测左边的数是否小于右边的，如果是，则返回 true。\n\n\n-ge\n检测左边的数是否大于等于右边的，如果是，则返回 true。\n\n\n-le\n检测左边的数是否小于等于右边的，如果是，则返回 true。\n\n\n布尔运算符\n\n\n!\n非运算，表达式为 true 则返回 false，否则返回 true。\n\n\n\n-o\n或运算，有一个表达式为 true 则返回 true。\n\n\n-a\n与运算，两个表达式都为 true 才返回 true。\n\n\n逻辑运算符\n\n\n&amp;&amp;\n逻辑的 AND\n\n\n\n&#124;&#124;\n逻辑的 OR\n\n\n字符串运算符\n\n\n=\n检测两个字符串是否相等，相等返回 true。\n\n\n\n!=\n检测两个字符串是否不相等，不相等返回 true。\n\n\n-z\n检测字符串长度是否为0，为0返回 true。\n\n\n-n\n检测字符串长度是否不为 0，不为 0 返回 true。\n\n\n$\n检测字符串是否为空，不为空返回 true。\n\n\n文件测试运算符\n\n\n-b file\n检测文件是否是块设备文件，如果是，则返回 true。\n\n\n\n-c file\n检测文件是否是字符设备文件，如果是，则返回 true。\n\n\n-d file\n检测文件是否是目录，如果是，则返回 true。\n\n\n-f file\n检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。\n\n\n-g file\n检测文件是否设置了 SGID 位，如果是，则返回 true。\n\n\n-k file\n检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。\n\n\n-p file\n检测文件是否是有名管道，如果是，则返回 true。\n\n\n-u file\n检测文件是否设置了 SUID 位，如果是，则返回 true。\n\n\n-r file\n检测文件是否可读，如果是，则返回 true。\n\n\n-w file\n检测文件是否可写，如果是，则返回 true。\n\n\n-x file\n检测文件是否可执行，如果是，则返回 true。\n\n\n-s file\n检测文件是否为空（文件大小是否大于0），不为空返回 true。\n\n\n-e file\n检测文件（包括目录）是否存在，如果是，则返回 true。\n\n\n流程控制if判断基本语法\n# 单分支if [ 条件判断式 ];then  程序fiif [ 条件判断式 ]then  程序fi# 多分支if [ 条件判断式 ]then  程序elif [ 条件判断式 ]then  程序else  程序fi\n举个栗子\n#!/bin/bashif [ $1 -eq 1 ]then  echo &quot;banzhang zhen shuai&quot;elif [ $1 -eq 2 ]then  echo &quot;cls zhen mei&quot;fi\ncase语法基本语法\ncase $变量名 in&quot;值 1&quot;）  如果变量的值等于值 1， 则执行程序 1;;&quot;值 2&quot;）  如果变量的值等于值 2， 则执行程序 2;;  …省略其他分支…*）  如果变量的值都不是以上的值， 则执行此程序;;esac\n注意事项：（1） case 行尾必须为单词“in” ， 每一个模式匹配必须以右括号“） ” 结束。（2） 双分号“;;” 表示命令序列结束， 相当于 java 中的 break。（3） 最后的“*） ” 表示默认模式， 相当于 java 中的 default。 \nfor循环基本语法\nfor (( 初始值;循环控制条件;变量变化 ))do  程序done\n举个栗子\n#!/bin/bashsum=0for((i=0;i&lt;=100;i++))do  sum=$[$sum+$i]doneecho $sum\nfor…in语法\nfor 变量 in 值 1 值 2 值 3…do  程序done\n举个栗子\n#!/bin/bash#打印数字for i in cls mly wlsdo  echo &quot;ban zhang love $i&quot;done\nwhile循环基本语法\nwhile [ 条件判断式 ]do  程序done\n举个栗子\n#!/bin/bashsum=0i=1while [ $i -le 100 ]do  sum=$[$sum+$i]  i=$[$i+1]doneecho $sum\n读取控制台输入\n基本语法\n\nread (选项) (参数)①选项：-p： 指定读取值时的提示符；-t： 指定读取值时等待的时间（秒） 如果-t 不加表示一直等待②参数变量： 指定读取值的变量名 \n\n举个栗子#!/bin/bashread -t 7 -p &quot;Enter your name in 7 seconds :&quot; NNecho $NN\n\n函数系统函数basename\n基本语法\n\nbasename [string / pathname] [suffix] （ 功能描述： basename 命令会删掉所有的前缀包括最后一个（‘/’） 字符， 然后将字符串显示出来。    basename 可以理解为取路径里的文件名称    选项：    suffix 为后缀， 如果 suffix 被指定了， basename 会将 pathname 或 string 中的 suffix 去掉 \n\n举个栗子\n# 以下可以取出banzhangbasename /home/lazy5/banzhang.txt .txt\ndirname\n基本语法\n\n\ndirname 文件绝对路径 （功能描述： 从给定的包含绝对路径的文件名中去除文件名（非目录的部分） ， 然后返回剩下的路径（目录的部分） ）    dirname 可以理解为取文件路径的绝对路径名称 \n\n举个栗子\n# /home/lazy5dirname /home/lazy5/banzhang.txt\n自定义函数\n基本语法\n[ function ] funname[()]&#123;  Action;  [return int;]&#125;\n说明\n\n\n（1） 必须在调用函数地方之前， 先声明函数， shell 脚本是逐行运行。 不会像其它语言一样先编译。（2） 函数返回值， 只能通过$?系统变量获得， 可以显示加： return 返回， 如果不加， 将以最后一条命令运行结果， 作为返回值。 return 后跟数值 n(0-255) \n\n举个栗子\n#!/bin/bashfunction sum()&#123;  s=0  s=$[$1+$2]  echo &quot;$s&quot;&#125;read -p &quot;Please input the number1: &quot; n1;read -p &quot;Please input the number2: &quot; n2;sum $n1 $n2;\n文件包含\n基本语法\n. filename   # 注意点号(.)和文件名中间有一空格或source filename\n举个栗子\n\n\ntest1.sh 代码如下：\n#!/bin/bashurl=&quot;http://www.starsea.club&quot;\ntest2.sh 代码如下：\n#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho &quot;我的地址：$url&quot;\n\n输入/输出重定向\n\n\n命令\n说明\n\n\n\ncommand &gt; file\n将输出重定向到 file。\n\n\ncommand &lt; file\n将输入重定向到 file。\n\n\ncommand &gt;&gt; file\n将输出以追加的方式重定向到 file。\n\n\nn &gt; file\n将文件描述符为 n 的文件重定向到 file。\n\n\nn &gt;&gt; file\n将文件描述符为 n 的文件以追加的方式重定向到 file。\n\n\nn &gt;&amp; m\n将输出文件 m 和 n 合并。\n\n\nn &lt;&amp; m\n将输入文件 m 和 n 合并。\n\n\n&lt;&lt; tag\n将开始标记 tag 和结束标记 tag 之间的内容作为输入。\n\n\n\n需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）\n\n输出重定向\n基本语法\ncommand1 &gt; file1\n举个栗子\n# 将who命令的结果输出到文件userswho &gt; users# 替换users的内容echo &quot;替换内容&quot; &gt; users# 追加内容到usersecho &quot;追加内容&quot; &gt;&gt; users\n\n输入重定向\n基本语法\ncommand1 &lt; file1\n举个栗子\n# 会输出2 users，行数+文件名wc -l users# 此处直接输出2，只显示行数，因为wc只知道是从标准输入读取的内容wc -l &lt; users\n\n同时输出/输入command1 &lt; infile &gt; outfile\ncommand1 &lt; infile &gt; outfile\n重定向深入讲解一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n\n标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。\n标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。\n标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。\n\n默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。如果希望 stderr 重定向到 file，可以这样写：\ncommand 2&gt;file# stderr追加command 2&gt;&gt;file\n如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：\ncommand &gt; file 2&gt;&amp;1或者command &gt;&gt; file 2&gt;&amp;1\n如果希望对 stdin 和 stdout 都重定向，可以这样写：\ncommand &lt; file1 &gt;file2\n\n/dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：\ncommand &gt; /dev/null\n如果希望屏蔽 stdout 和 stderr，可以这样写：\ncommand &gt; /dev/null 2&gt;&amp;1\n","categories":["服务器"],"tags":["shell","sh","bash"]},{"title":"vue-virtual-scroller源码分析","url":"/2021/11/20/vue-virtual-scroller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"该插件目的当页面数据量较大，例如有几千条数据渲染的时候，dom过多产生滚动卡顿的现象。此时使用该插件可以动态渲染可视区的dom，滚动时实时计算和变更可视区显示的数据。\n原理根据可视区的高度以及items中每一项的高度(itemSize，可为高度或者是横向滑动的宽度)来决定页面展示多少个item，能显示的item包装后放到了pool数组中进行渲染，页面滚动的时候动态的修改pool数组。为了在滚动的时候尽可能的减少开销，pool中超出范围的view会回收到复用池，pool中新增的view会优先从复用池中取出view，如果没有复用的才会新增。\n页面中数据流动为了达到动态渲染和dom复用的目的，主要维护了一下三个存放对应item的池子。\n\npool：当前页面显示得视图池，存储当前页面要渲染得数据，即pool是tempalte中渲染真实使用到的。&lt;div    v-for=&quot;view of pool&quot;    :key=&quot;view.nr.id&quot;    :style=&quot;ready ? &#123; transform: `translate$&#123;direction === &#x27;vertical&#x27; ? &#x27;Y&#x27; : &#x27;X&#x27;&#125;($&#123;view.position&#125;px)` &#125; : null&quot;    class=&quot;vue-recycle-scroller__item-view&quot;    :class=&quot;&#123; hover: hoverKey === view.nr.key &#125;&quot;    @mouseenter=&quot;hoverKey = view.nr.key&quot;    @mouseleave=&quot;hoverKey = null&quot;&gt;\n$_views: 和pool对应，每一次addView新增一个视图得时候，除了要把视图放到pool中，还要放一份到views中。只是views是map，数据字典方便查找view，当页面滚动得时候，会取范围在startIndex和endIndex之间得view，每个view先去views中找，这样比在pool中遍历效率要高，如果找到了说明当前view一直在可视区内，这个时候直接显示复用views中得即可。如果在views中没找到，说明是新增得view，则先去复用池中根据type找，找到则复用，找不到则addView新增，新增之后views中也要加进去。\n$_unusedViews: 复用池，根据type存储不在可视区的视图。每次滚动先把超出可视区的丢到unusedViews，丢完之后。进行startIndex和endIndex之间的可视区遍历，在新增view出现的时候优先在unusedViews中找，找到就取出来。找不到则走addView\n\n\n以下是初始化的时候对数据的初始化\n\ncreated () &#123;    // 记录刷新完成的开始索引    this.$_startIndex = 0    // 记录刷新完成的结束索引    this.$_endIndex = 0    // 页面上所有展示的视图，与pool对应，方便快速查找    this.$_views = new Map()    // 复用池：根据视图的type暂存不在使用的view    this.$_unusedViews = new Map()    // 标记是否正在滚动，用于滚动节流    this.$_scrollDirty = false    // 记录上一次滚到了哪里start值    this.$_lastUpdateScrollPosition = 0    // In SSR mode, we also prerender the same number of item for the first render    // to avoir mismatch between server and client templates    if (this.prerender) &#123;      this.$_prerender = true      this.updateVisibleItems(false)    &#125;&#125;,\n\n原理整个插件最主要的原理集中在updateVisibleItems(视图刷新函数)，该函数会在初始化、页面滚动、页面resize等情况下触发。总共的过程分为以下四步：\n\n计算可视范围：获取scroll信息后，先算出此次需要展现到可视区的items索引范围，即startIndex和endIndex。\n\n获取当前展示部分的start、end值, 并判断是否进行了足够的滚动。滚动较小则可视区展示的items不变动，不需要刷新。// 获取当前可视区的范围，getScroll根据scrollerTop等计算const scroll = this.getScroll()// Skip update if use hasn&#x27;t scrolled enough    if (checkPositionDiff) &#123;      // 此处判断当前滚动的范围未超出设置的itemSize，即没有超过一个view，此时pool不需要改变，则此次不进行update操作      let positionDiff = scroll.start - this.$_lastUpdateScrollPosition      if (positionDiff &lt; 0) positionDiff = -positionDiff      if ((itemSize === null &amp;&amp; positionDiff &lt; minItemSize) || positionDiff &lt; itemSize) &#123;        return &#123;          continuous: true,        &#125;      &#125;    &#125;    // 刷新此次滚动后的位置信息    this.$_lastUpdateScrollPosition = scroll.start    // 计算偏移量，默认buffer为200，可自定义    const buffer = this.buffer    scroll.start -= buffer    scroll.end += buffer    // Variable size mode    // 高度可变模式    // 因为每个item的高度不固定，无法直接用scroll.start得到startIndex。所以通过二分法快速查找到第一个出现在可视区的视图，即startIndex。    // 由于计算属性已缓存了可变高度的所有size记录，二分法查找的目的等价于查找到sizes中的索引，该索引满足index项的accumulator小于scroll.start，index+1项的accumulator大于scroll.start，则为刚滑到可视区的startIndex    if (itemSize === null) &#123;      let h      let a = 0      let b = count - 1      // 此处记录二分查找起始点      let i = ~~(count / 2)      let oldI      // Searching for startIndex      do &#123;        oldI = i        h = sizes[i].accumulator        if (h &lt; scroll.start) &#123;          // 说明此次i取小了，则最小值设置为i          a = i        &#125; else if (i &lt; count - 1 &amp;&amp; sizes[i + 1].accumulator &gt; scroll.start) &#123;          // 说明i、i+1都超出了范围，则最大值设置为i，继续查找          b = i        &#125;        // 继续二分        i = ~~((a + b) / 2)      &#125; while (i !== oldI)      i &lt; 0 &amp;&amp; (i = 0)      startIndex = i      // For container style      totalSize = sizes[count - 1].accumulator      // Searching for endIndex      // 找到刚好超出的endIndex      for (endIndex = i; endIndex &lt; count &amp;&amp; sizes[endIndex].accumulator &lt; scroll.end; endIndex++);      if (endIndex === -1) &#123;        endIndex = items.length - 1      &#125; else &#123;        endIndex++        // Bounds        endIndex &gt; count &amp;&amp; (endIndex = count)      &#125;    &#125; else &#123;      // Fixed size mode      // 固定高度：根据滚动的距离计算固定itemSize的startIndex和endIndex      startIndex = ~~(scroll.start / itemSize)      endIndex = Math.ceil(scroll.end / itemSize)      // Bounds      startIndex &lt; 0 &amp;&amp; (startIndex = 0)      endIndex &gt; count &amp;&amp; (endIndex = count)      totalSize = count * itemSize    &#125;  &#125;  if (endIndex - startIndex &gt; config.itemsLimit) &#123;    this.itemsLimitError()  &#125;  // 刷新items的总高度, totalSize会给到外层盒子的高度，为了制造出滚动条  this.totalSize = totalSize\n对于可变高度，计算属性会优先维护一个sizes表，已记录对应索引的size累计值。此操作目的是为了后续根据索引即可拿到size之和，而不必每次都重新计算。sizes () &#123;  // itemSize不提供，则进入variable size mode  if (this.itemSize === null) &#123;    const sizes = &#123;      &#x27;-1&#x27;: &#123; accumulator: 0 &#125;,    &#125;    const items = this.items    const field = this.sizeField    const minItemSize = this.minItemSize    let computedMinSize = 10000    let accumulator = 0    let current    for (let i = 0, l = items.length; i &lt; l; i++) &#123;      current = items[i][field] || minItemSize      if (current &lt; computedMinSize) &#123;        computedMinSize = current      &#125;      accumulator += current      sizes[i] = &#123; accumulator, size: current &#125;    &#125;    // eslint-disable-next-line    this.$_computedMinItemSize = computedMinSize    return sizes  &#125;  return []&#125;\n\n\n视图回收：遍历pool中视图，判断view的索引超出startIndex、endIndex范围，则走到unuseView函数进行视图回收，放到复用池unusedViews。(此时放到复用池只是放的引用，仍指向pool中对应的元素，不会改变pool元素个数，只改对应元素的属性\n\n\nif (this.$_continuous !== continuous) &#123;    if (continuous) &#123;        // 不是连续滑动，则页面出现了大的改变，初始化数据        views.clear()        unusedViews.clear()        for (let i = 0, l = pool.length; i &lt; l; i++) &#123;            // 将当前显示的view回收            view = pool[i]            this.unuseView(view)        &#125;    &#125;    this.$_continuous = continuous&#125; else if (continuous) &#123;    // 此时为连续滑动，遍历回收pool    for (let i = 0, l = pool.length; i &lt; l; i++) &#123;        view = pool[i]        if (view.nr.used) &#123;            // Update view item index            if (checkItem) &#123;                view.nr.index = items.findIndex(                item =&gt; keyField ? item[keyField] === view.item[keyField] : item === view.item,                )            &#125;            // Check if index is still in visible range            // 此处判断如果，index已经超出范围，则进行回收            if (                view.nr.index === -1 ||                view.nr.index &lt; startIndex ||                view.nr.index &gt;= endIndex            ) &#123;                this.unuseView(view)            &#125;        &#125;    &#125;&#125;\n\n以下为unuseView的实现：\nunuseView (view, fake = false) &#123;    // 根据view的类别放到缓存池    const unusedViews = this.$_unusedViews    const type = view.nr.type    // 根据type类别进行存放，后续复用也是根据type去取    let unusedPool = unusedViews.get(type)    if (!unusedPool) &#123;        unusedPool = []        unusedViews.set(type, unusedPool)    &#125;    unusedPool.push(view)    if (!fake) &#123;        // 此时将视图回收设置位置（让view不可见），且used置为false        view.nr.used = false        view.position = -9999        this.$_views.delete(view.nr.key)    &#125;&#125;\n\n\n更新视图：在startIndex和endIndex之间遍历，每次拿到items中的一个item，开始包装item后刷到pool中。\n根据item取views字典中查找，如果找到了，则当前view还在可视区，只是滚动了，则直接复用view即可。\n在views中未找到，则去unusedViews中找有没有可复用的view，有则使用复用视图，修改view的item、key、index等属性后即可。且后面重新设置views中对应字典，方便后面查找。\n如果unusedViews中未找到，则无复用view。此时调用addView新增视图，view增加item属性关联到items、position属性后面用于transform样式、增加used、key、id、index等标识。新增视图push到pool中，同时在views中增加字典。\n\n\n\nlet item, type, unusedPoollet v// 在可视区范围内遍历for (let i = startIndex; i &lt; endIndex; i++) &#123;  item = items[i]  const key = keyField ? item[keyField] : item  if (key == null) &#123;    throw new Error(`Key is $&#123;key&#125; on item (keyField is &#x27;$&#123;keyField&#125;&#x27;)`)  &#125;  // 3.1 根据item取views字典中查找，如果找到了，则当前view还在可视区，只是滚动了，则直接复用view即可。  view = views.get(key)  // 此处size不存在，则高度不存在，则不加到pool，因为显示不出来  if (!itemSize &amp;&amp; !sizes[i].size) &#123;    if (view) this.unuseView(view)    continue  &#125;  // No view assigned to item  // 3.2 在views中未找到，则去unusedViews中找有没有可复用的view，有则使用复用视图，修改view的item、key、index等属性后即可。且后面重新设置views中对应字典，方便后面查找。  if (!view) &#123;    type = item[typeField]    unusedPool = unusedViews.get(type)    if (continuous) &#123;      // Reuse existing view      // 根据类型找出复用池中可用的的视图，修改索引等进行复用      if (unusedPool &amp;&amp; unusedPool.length) &#123;        view = unusedPool.pop()        view.item = item        view.nr.used = true        view.nr.index = i        view.nr.key = key        view.nr.type = type      &#125; else &#123;        // 复用池中不存在则新增        // 3.3 如果unusedViews中未找到，则无复用view。此时调用addView新增视图，view增加item属性关联到items、position属性后面用于transform样式、增加used、key、id、index等标识。新增视图push到pool中，同时在views中增加字典。        view = this.addView(pool, i, item, key, type)      &#125;    &#125; else &#123;      // Use existing view      // We don&#x27;t care if they are already used      // because we are not in continous scrolling      // 因为不是连续滑动，无交叉，不用考虑使用占用的问题，直接从对应复用池中的第一个开始找      v = unusedIndex.get(type) || 0      if (!unusedPool || v &gt;= unusedPool.length) &#123;        view = this.addView(pool, i, item, key, type)        this.unuseView(view, true)        unusedPool = unusedViews.get(type)      &#125;      view = unusedPool[v]      view.item = item      view.nr.used = true      view.nr.index = i      view.nr.key = key      view.nr.type = type      unusedIndex.set(type, v + 1)      v++    &#125;    // 放到views池中，此处对应字典，方便后续查找    views.set(key, view)  &#125; else &#123;    // 当前视图中已经存在，则直接重新used即可    view.nr.used = true    view.item = item  &#125;  // Update position  // 刷新视图位置  if (itemSize === null) &#123;    view.position = sizes[i - 1].accumulator  &#125; else &#123;    view.position = i * itemSize  &#125;&#125;// 记录本地的索引this.$_startIndex = startIndexthis.$_endIndex = endIndex\n\n以下是addView的逻辑，复用池没有的时候走到addView新增视图：\naddView (pool, index, item, key, type) &#123;const view = &#123;  item,  position: 0,&#125;const nonReactive = &#123;  id: uid++,  // 此处的index对应传进来的源数据中的索引，方便后续视图复用后重新排序  index,  used: true,  key,  type,&#125;Object.defineProperty(view, &#x27;nr&#x27;, &#123;  configurable: false,  value: nonReactive,&#125;)// 新增视图放到pool当中pool.push(view)return view&#125;\n\n\n\n排序视图：以上处理完成之后pool可能是无序的，因为存在复用池复用等情况，因此要进行排序，调用sortViews方法会根据pool中视图存的index值进行重排。\n\nclearTimeout(this.$_sortTimer)this.$_sortTimer = setTimeout(this.sortViews, 300)// sortViews的实现sortViews () &#123;  this.pool.sort((viewA, viewB) =&gt; viewA.nr.index - viewB.nr.index)&#125;\n\n结语该插件中pool、$_unusedViews、$_views三者对应的处理是很值得学习的。$_unusedViews的使用使得不比每次都去删减pool的数据达到渲染的目的，反观自己平时的开发，类似滚动、轮播等处理的方式，大概率直接截取源数据的某一范围给到pool达到刷新目的，效果是实现，但是有优化的空间。$_views的使用、以及计算属性sizes的使用均是为了降低复杂度，对于我们动不动就遍历、findIndex等处理，这种预先存储进map、或者预先存储累加值的做法更为优雅，同时也大大的降低了复杂度，减少在每次刷新视图中的遍历逻辑。\n","categories":["前端"],"tags":["Vue"]},{"title":"svg学习记录","url":"/2022/05/13/svg-study/","content":"常用形状矩形&lt;rect x=&quot;60&quot; y=&quot;10&quot; rx=&quot;10&quot; ry=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nx\n矩形左上角的x位置\n\n\ny\n矩形左上角的y位置\n\n\nwidth\n矩形的宽度\n\n\nheight\n矩形的高度\n\n\nrx\n圆角的x方位的半径\n\n\nry\n圆角的y方位的半径\n\n\n圆形&lt;circle cx=&quot;25&quot; cy=&quot;75&quot; r=&quot;20&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nr\n圆的半径\n\n\ncx\n圆心的x位置\n\n\ncy\n圆心的y位置\n\n\n椭圆&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nrx\n椭圆的x半径\n\n\nry\n椭圆的y半径\n\n\ncx\n椭圆中心的x位置\n\n\ncy\n椭圆中心的y位置\n\n\n线条&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot;/&gt;\n\n\n\n参数名\n描述\n\n\n\nx1\n起点的x位置\n\n\ny1\n起点的y位置\n\n\nx2\n终点的x位置\n\n\ny2\n终点的y位置\n\n\n折线&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot;/&gt;\npoints点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。\n多边形&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot;/&gt;\npoints点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。\n路径&lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;\n参数含义：\n\nM = moveto\nL = lineto\nH = horizontal lineto\nV = vertical lineto\nC = curveto\nS = smooth curveto\nQ = quadratic Bézier curve\nT = smooth quadratic Bézier curveto\nA = elliptical Arc\nZ = closepath\n以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。\n\n\n\n贝塞尔曲线\n三次贝塞尔曲线\n// 语法C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)// 举例&lt;path d=&quot;M70 10 C 70 20, 120 20, 120 10&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点\n\n三次贝塞尔曲线简化\n\n\n一般情况下，三次贝塞尔曲线的两个控制点对称，因此可以简化只写一个控制点。语法如下：\nS x2 y2, x y (or s dx2 dy2, dx dy)\n当S命令之前是C或者S命令的时候，这里的第一个控制点将是前面曲线的第二个控制点的中心对称点。\n&lt;path d=&quot;M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n\n\n二次贝塞尔曲线\n\n二次贝塞尔曲线仅需要一个控制点，来确认起点和终点的曲线斜率\n// 语法 Q x1 y1, x y (or q dx1 dy1, dx dy)// 举例&lt;path d=&quot;M10 80 Q 95 10 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n\n\n二次贝塞尔曲线简化\n\n当此前已有Q命令的时候，可以省去控制点，自动推算出一个新的控制点。如果此前无Q命令，则推算的控制点为终点，画出来的为直线。\n// 语法T x y (or t dx dy)// 举例&lt;path d=&quot;M10 80 Q 52.5 10, 95 80 T 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;\n弧形// 语法 A rx ry x-axis-rotation large-arc-flag sweep-flag x y a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy// 举例&lt;path d=&quot;M10 315           L 110 215           A 30 50 0 0 1 162.55 162.45           L 172.55 152.45           A 30 50 -45 0 1 215.1 109.9           L 315 10&quot; stroke=&quot;black&quot; fill=&quot;green&quot; stroke-width=&quot;2&quot; fill-opacity=&quot;0.5&quot;/&gt;\n参数的含义：rx、ry表示椭圆的x轴和y轴的半径x-axis-rotation表示x轴旋转角度，0则表示弧形所在的椭圆是正置的large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧\n填充与边框常用参数列举：\n\n\n\n参数名\n描述\n\n\n\nfill\n填充色\n\n\nstroke\n描边色\n\n\nfill-opacity\n填充色的不透明度\n\n\nstroke-opacity\n描边色的不透明度\n\n\nstroke-width\n描边宽度\n\n\nstroke-linecap\n边框终点的形状：\n\n\nbutt直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点\n\n\n\nsquare的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制\n\n\n\nround表示边框的终点是圆角，圆角的半径也是由stroke-width控制的\n\n\n\nstroke-linejoin\nmiter是默认值，表示用方形画笔在连接处形成尖角，round表示用圆角连接，实现平滑效果。bevel，连接处会形成一个斜接\n\n\nstroke-dasharray\n定义描边虚线类型，由一组用逗号分隔的数字组成。交替表示填色单位长度、空白单位长度。\n\n\n举例\n&lt;svg width=&quot;200&quot; height=&quot;150&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;  &lt;path d=&quot;M 10 75 Q 50 10 100 75 T 190 75&quot; stroke=&quot;black&quot;    stroke-linecap=&quot;round&quot; stroke-dasharray=&quot;5,10,5&quot; fill=&quot;none&quot;/&gt;  &lt;path d=&quot;M 10 75 L 190 75&quot; stroke=&quot;red&quot;    stroke-linecap=&quot;round&quot; stroke-width=&quot;1&quot; stroke-dasharray=&quot;5,5&quot; fill=&quot;none&quot;/&gt;&lt;/svg&gt;\n渐变定义在&lt;defs&gt;标签内，指定id，其他元素通过id引用。可以用于fill、stroke\n线性渐变&lt;svg width=&quot;120&quot; height=&quot;240&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  &lt;defs&gt;      // 默认水平渐变      &lt;linearGradient id=&quot;Gradient1&quot;&gt;        &lt;stop class=&quot;stop1&quot; offset=&quot;0%&quot;/&gt;        &lt;stop class=&quot;stop2&quot; offset=&quot;50%&quot;/&gt;        &lt;stop class=&quot;stop3&quot; offset=&quot;100%&quot;/&gt;      &lt;/linearGradient&gt;          // 垂直渐变      &lt;linearGradient id=&quot;Gradient2&quot; x1=&quot;0&quot; x2=&quot;0&quot; y1=&quot;0&quot; y2=&quot;1&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;50%&quot; stop-color=&quot;black&quot; stop-opacity=&quot;0&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/linearGradient&gt;          // 通过样式执行      &lt;style type=&quot;text/css&quot;&gt;&lt;![CDATA[        #rect1 &#123; fill: url(#Gradient1); &#125;        .stop1 &#123; stop-color: red; &#125;        .stop2 &#123; stop-color: black; stop-opacity: 0; &#125;        .stop3 &#123; stop-color: blue; &#125;      ]]&gt;&lt;/style&gt;  &lt;/defs&gt;  &lt;rect id=&quot;rect1&quot; x=&quot;10&quot; y=&quot;10&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;  &lt;rect x=&quot;10&quot; y=&quot;120&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#Gradient2)&quot;/&gt;&lt;/svg&gt;\nx1、x2、y1、y2指定了渐变的方向\n径向渐变&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;120&quot; height=&quot;240&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  &lt;defs&gt;      &lt;radialGradient id=&quot;RadialGradient1&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/radialGradient&gt;      &lt;radialGradient id=&quot;RadialGradient2&quot; cx=&quot;0.25&quot; cy=&quot;0.25&quot; r=&quot;0.25&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/radialGradient&gt;          // 指定渐变焦点      &lt;radialGradient id=&quot;Gradient&quot;          cx=&quot;0.5&quot; cy=&quot;0.5&quot; r=&quot;0.5&quot; fx=&quot;0.25&quot; fy=&quot;0.25&quot;&gt;        &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot;/&gt;        &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot;/&gt;      &lt;/radialGradient&gt;  &lt;/defs&gt;  &lt;rect x=&quot;10&quot; y=&quot;10&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#RadialGradient1)&quot;/&gt;  &lt;rect x=&quot;10&quot; y=&quot;120&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#RadialGradient2)&quot;/&gt;  &lt;rect x=&quot;10&quot; y=&quot;10&quot; rx=&quot;15&quot; ry=&quot;15&quot; width=&quot;100&quot; height=&quot;100&quot;        fill=&quot;url(#Gradient)&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot;/&gt;&lt;/svg&gt;\ncx、cy、r 指定了镜像渐变的范围，fx、fy 指定了焦点，即渐变的中心点\n文字x、y指定文本在视口中显示的位置。属性text-anchor指定文本流的方向，可选sstart、middle、end、inherit\n&lt;text x=&quot;10&quot; y=&quot;10&quot;&gt;Hello World!&lt;/text&gt;\n可使用的属性：font-family、font-style、font-weight、font-variant、font-stretch、font-size、font-size-adjust、kerning、letter-spacing、word-spacing和text-decoration其他用法：\n// tspan指定子元素&lt;text&gt;  &lt;tspan font-weight=&quot;bold&quot; fill=&quot;red&quot;&gt;This is bold and red&lt;/tspan&gt;&lt;/text&gt;// tref引用已经定义的文本&lt;text id=&quot;example&quot;&gt;This is an example text.&lt;/text&gt;&lt;text&gt;    &lt;tref xlink:href=&quot;#example&quot; /&gt;&lt;/text&gt;// textPath指定文字沿着路径环绕&lt;path id=&quot;my_path&quot; d=&quot;M 20,20 C 40,40 80,40 100,20&quot; fill=&quot;transparent&quot; /&gt;&lt;text&gt;  &lt;textPath xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#my_path&quot;&gt;    This text follows a curve.  &lt;/textPath&gt;&lt;/text&gt;\n基础变形元素元素用于将属性赋给整个元素集合\n&lt;g fill=&quot;red&quot;&gt;  &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; /&gt;  &lt;rect x=&quot;20&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; /&gt;&lt;/g&gt;\n平移translate&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; transform=&quot;translate(30,40)&quot; /&gt;\n旋转rotate&lt;rect x=&quot;20&quot; y=&quot;20&quot; width=&quot;20&quot; height=&quot;20&quot; transform=&quot;rotate(45)&quot; /&gt;\n其他变换skewX()x轴斜切skewY()y轴斜切scale()缩放\n剪切和遮罩剪切在剪切范围内的元素才会显示，如下代码仅显示上半部的圆形\n&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;  &lt;defs&gt;    &lt;clipPath id=&quot;cut-off-bottom&quot;&gt;      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; /&gt;    &lt;/clipPath&gt;  &lt;/defs&gt;  &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;100&quot; clip-path=&quot;url(#cut-off-bottom)&quot; /&gt;&lt;/svg&gt;\n遮罩以下代码使用渐变遮罩，水平方向不透明度从0到1，则红色的矩形从左到右逐渐显示，叠加后产生渐变效果。\n&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;  &lt;defs&gt;    &lt;linearGradient id=&quot;Gradient&quot;&gt;      &lt;stop offset=&quot;0&quot; stop-color=&quot;white&quot; stop-opacity=&quot;0&quot; /&gt;      &lt;stop offset=&quot;1&quot; stop-color=&quot;white&quot; stop-opacity=&quot;1&quot; /&gt;    &lt;/linearGradient&gt;    &lt;mask id=&quot;Mask&quot;&gt;      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; fill=&quot;url(#Gradient)&quot;  /&gt;    &lt;/mask&gt;  &lt;/defs&gt;  &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; fill=&quot;green&quot; /&gt;  &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; fill=&quot;red&quot; mask=&quot;url(#Mask)&quot; /&gt;&lt;/svg&gt;\n滤镜滤镜元素可参考mdn文档：https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element#%E6%BB%A4%E9%95%9C%E5%85%83%E7%B4%A0以下列举一个阴影效果的代码：\n  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;  &lt;defs&gt;    &lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200%&quot; height=&quot;200%&quot;&gt;      &lt;feOffset result=&quot;offOut&quot; in=&quot;SourceAlpha&quot; dx=&quot;20&quot; dy=&quot;20&quot; /&gt;      &lt;feGaussianBlur result=&quot;blurOut&quot; in=&quot;offOut&quot; stdDeviation=&quot;10&quot; /&gt;      &lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;blurOut&quot; mode=&quot;normal&quot; /&gt;    &lt;/filter&gt;  &lt;/defs&gt;  &lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot;  fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;&lt;/svg&gt;\nfeOffset使用Alpha通道残影偏移，接着feGaussianBlur使用偏移的结果进行高斯模糊，最后feBlend将原图像和上一步模糊后的阴影结合生成最后的效果。\n图片&lt;svg width=&quot;5cm&quot; height=&quot;4cm&quot; version=&quot;1.1&quot;     xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink= &quot;http://www.w3.org/1999/xlink&quot;&gt;\t&lt;image xlink:href=&quot;firefox.jpg&quot; x=&quot;0&quot; y=&quot;0&quot; height=&quot;50px&quot; width=&quot;50px&quot;/&gt;&lt;/svg&gt;\n\n\n如果你没有设置x属性或y属性，它们自动被设置为0。\n如果你没有设置height属性或width属性，它们自动被设置为0。\n如果width属性或height等于0，将不会呈现这个图像。\n\n\nSVG.js的使用以上了解了svg基本的语法，但是自己绘制svg还是比较麻烦，这里记录下SVG.js库的使用，可以简化绘制流程。\n快速使用可以cdn引入和npm安装，这里以Vue为例\nnpm install @svgdotjs/svg.js\n&lt;template&gt;  &lt;div id=&quot;svg&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; SVG &#125; from &quot;@svgdotjs/svg.js&quot;onMounted(() =&gt; &#123;  // 通过addTo方法将SVG挂载到dom上，通过size设置大小  let draw = SVG().addTo(&quot;#svg&quot;).size(&quot;100%&quot;, &quot;100%&quot;);    // 这里绘制一个100大小的矩形，并绑定了点击事件  draw.rect(100, 100).attr(&#123; fill: &quot;#00B1B6&quot; &#125;).click(function() &#123;    this.fill(&#x27;#ff0000&#x27;)  &#125;);&#125;)&lt;/script&gt;\n常用绘图绘图方法名称和svg形状名称基本一致，然后通过attr可设置属性，同时也可以通过属性名直接设置。使用方式和jQuery类似，支持链式调用。\n// 绘制矩形，设置矩形圆角var rect = draw.rect(100, 100)rect.radius(10)// 绘制占据100，直径半径50的圆draw.circle(100).radius(50)// 绘制长宽200/100的椭圆，x、y半径分别为75、50var ellipse = draw.ellipse(200, 100).radius(75, 50)// 直线绘制var line = draw.line(0, 0, 100, 150).stroke(&#123; width: 1 &#125;)// 多线段绘制var polyline = draw.polyline(&#x27;0,0 100,50 50,100&#x27;).fill(&#x27;none&#x27;).stroke(&#123; width: 1 &#125;)var polyline1 = draw.polyline([[0,0], [100,50], [50,100]])var polyline2 = draw.polyline([0,0, 100,50, 50,100])// 路径的绘制draw.path(&#x27;M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z&#x27;)// 图片绘制，图片加载后的回调处理var image = draw.image(&#x27;/path/to/image.jpg&#x27;, function (event) &#123;  // image loaded  // this is the loading event for the underlying img element  // you can access the natural width and height of the image with  // event.target.naturalWidth, event.target.naturalHeight&#125;)// 线性渐变var gradient = draw.gradient(&#x27;linear&#x27;, function(add) &#123;  add.stop(0, &#x27;#333&#x27;)  add.stop(1, &#x27;#fff&#x27;)&#125;)rect.fill(gradient)// 镜像渐变var gradient = draw.gradient(&#x27;radial&#x27;, function(add) &#123;  add.stop(0, &#x27;#333&#x27;)  add.stop(1, &#x27;#fff&#x27;)&#125;)gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)\n位置\n通过attr\n// 矩形根据左上角移动rect.attr(&#123; x: 20, y: 60 &#125;)// 圆形根据中心点移动circle.attr(&#123; cx: 50, cy: 40 &#125;)\n通过x、y坐标设置\n// 通过坐标轴移动方法时，均可以使用左上角和中心点，仅支持无单位坐标rect.cx(20).cy(60)circle.x(50).y(40)\n通过move方法\n// 通过move方法指定坐标，左上角基准rect.move(200, 350)// 等价于rect.x(200).y(350)// 中心点移动rect.center(150, 150)// 等价于rect.cx(200).cy(350)// 相对坐标移动rect.dmove(10, 30)// 等价于rect.dx(10).dy(30)\n动画动画使用animate方法，再调用attr、move等方法之前使用。以下为使用的举例：\n\n默认\n\n\n默认情况下duration将设置为400，delay将设置为0并when设置为after。\nrect.animate().move(150, 150)\n\n\n常用参数\n\n第一个是duration，第二个delay和第三个when。when参数的取值：\n\nnow：在此调用执行后立即播放动画\nabsolute或start：将动画安排到时间线上的绝对时间\nrelative：安排动画相对于其旧开始时间播放（对 animate() 调用无用）\nlast或after：在时间轴上最后一个动画之后播放动画。如果没有，则立即播放动画（请参阅now）rect.animate(2000, 1000, &#x27;now&#x27;).attr(&#123; fill: &#x27;#f03&#x27; &#125;)\n\n\n对象形式多参数\nrect.animate(&#123;  duration: 2000,  delay: 1000,  when: &#x27;now&#x27;,  swing: true,  times: 5,  wait: 200&#125;).attr(&#123; fill: &#x27;#f03&#x27; &#125;)// 多个动画链接在一起rect.animate().attr(&#123; fill: &#x27;#f03&#x27; &#125;).animate().dmove(50,50)// 动画之间添加延迟rect.animate().attr(&#123; fill: &#x27;#f03&#x27; &#125;).delay(200).animate().dmove(50,50)// 直接在动画里面加延迟rect.animate().attr(&#123; fill: &#x27;#f03&#x27; &#125;).animate(&#123;delay: 200&#125;).dmove(50,50)\n缓动设置\n\n\n缓动类型包括：\n\n&lt;&gt;: ease in and out\n&gt;: ease out\n&lt;: ease in\n-: linear\n函数\nbeziere(x1, y1, x2, y2)\nstep(steps, stepPosition) draw.circle(100).radius(50).fill(&quot;#ccB1B6&quot;).animate(&#123; duration: 2000 &#125;).ease(&#x27;&lt;&#x27;).dmove(100);\n事件支持常见事件的绑定，例如：click、dblclick、mousedown、mouseup、mousemove、mouseout、mousemove、touchstart、touchmove、touchleave、touchend、touchcancel等单事件绑定可直接通过事件名绑定：element.click(function() &#123;  this.fill(&#123; color: &#x27;#f06&#x27; &#125;)&#125;)// 解绑事件element.click(null)\non绑定可通过on绑定单个或多个事件：// 单个事件绑定var click = function() &#123;  this.fill(&#123; color: &#x27;#f06&#x27; &#125;)&#125;element.on(&#x27;click&#x27;, click)// 多个事件绑定element.on([&#x27;click&#x27;, &#x27;mouseover&#x27;], handler)element.on(&#x27;click mouseover&#x27;, handler)// 指定上下文element.on(&#x27;click&#x27;, click, window)// 解绑事件element.off(&#x27;click&#x27;, click)element.off(&#x27;click&#x27;)element.off([&#x27;click&#x27;, &#x27;mouseover&#x27;])element.off(&#x27;click mouseover&#x27;)element.off()\n自定义事件自定义事件的绑定：element.on(&#x27;myevent&#x27;, function() &#123;  alert(&#x27;ta-da!&#x27;)&#125;)\n事件和自定义事件可以通过fire、dispatch触发，区别在于fire返回element、而dispatch返回事件对象。// 触发事件element.fire(&#x27;myevent&#x27;)// 携带参数element.fire(&#x27;myevent&#x27;, &#123;some:&#x27;data&#x27;&#125;)// dispatch的使用var event = element.dispatch(event)\n结语除了SVG.js外还有其他的库可以方便操作svg，也可以自己封装一些常用的操作。这里再推荐一个草绘风格的绘图库，Rough.js\n\n","categories":["前端"],"tags":["svg","SVG.js"]},{"title":"设计模式","url":"/2021/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"单例模式惰性单例模式封装\nvar getSingle = function (fn) &#123;    var result;    return function () &#123;        return result || ( result = fn.apply(this, arguments) );    &#125;&#125;\n\n策略模式\n定义：定义一系列的算法，把他们一个个封装起来，并使他们可以相互替换。除了算法外，策略模式还可以用来封装一系列的业务规则，例如：表单校验，业务规则可以对应表单校验的规则和错误的提示语。定义好规则策略后，需要校验的地方传入规则名和错误提示即可。\n\n代理模式\n定义：代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。\n\n保护代理：可以增加条件做过滤，拒绝掉一部分的请求，控制不同权限的对象对目标对象的访问虚拟代理：对耗时或者可合并的操作等，做延迟处理，在合适的时机触发。例如：加载图片、合并接口请求等。\n合并请求的虚拟代理例子：\nvar synchromousFile = function ( id ) &#123;    console.log(&#x27;开始同步文件，id为&#x27; + id);&#125;;var proxySynchronousFile = (function () &#123;    var cache = [], // 保存一段时间内需要同步的ID集合    timer;    return function( id ) &#123;        cache.push(id);        if ( timer ) &#123;            return;        &#125;        timer = setTimeout(function() &#123;            synchromousFile( cache.join(&#x27;,&#x27;)); // 2秒后向本体发送需要同步的ID集合            clearTimeout( timer );            timer = null;            cache.length = 0; //清空ID集合        &#125;, 2000)    &#125;&#125;)();\n发布-订阅模式\n定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。优点：一为时间上的解耦，二为对象之间的解耦。缺点：过多的使用会使得模块之间的联系被隐藏到了背后。\n\n以下为全局的发布-订阅对象：\nvar Event = (function () &#123;    var clientList = &#123;&#125;,        listen,        trigger,        remove;        listen = function (key, fn) &#123;        if (!clientList[ key ]) &#123;            clientList[ key ] = [];        &#125;        clientList[ key ].push( fn );    &#125;;    trigger = function () &#123;        var key = Array.prototype.shift.call( arguments ),            fns = clientList[ key ];            if ( !fns || fns.length === 0) &#123;                return false;            &#125;            for ( var i = 0, fn; fn = fns[ i++ ]; ) &#123;                fn.apply( this, arguments);            &#125;    &#125;    remove = function ( key, fn ) &#123;        var fns = clientList[ key ];        if ( !fns ) &#123;            return false;        &#125;        if ( !fn ) &#123;            fns &amp;&amp; ( fns.length = 0);        &#125; else &#123;            for ( var l = fns.length - 1; l &gt;= 0; l--) &#123;                var _fn = fns[ l ];                if ( _fn === fn ) &#123;                    fns.splice( l, 1);                &#125;            &#125;        &#125;    &#125;;    return &#123;        listen: listen,        trigger: trigger,        remove: remove    &#125;&#125;)();\n\n命令模式\n定义：指的是一个执行某些特定事情的指令。最常用的场景：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。命令模式支持撤销、排队、宏命令等。\n\n使用闭包的命令模式：\nvar setCommand = function ( button, func ) &#123;    button.onclick = function () &#123;        func();    &#125;&#125;;var MenuBar = &#123;    refresh: function () &#123;        console.log( &#x27;刷新&#x27; );    &#125;&#125;;var RefreshMenuBarCommand = function ( receiver ) &#123;    return function () &#123;        receiver.refresh();    &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar );setCommand( button1, refreshMenuBarCommand);\n\n组合模式组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明。\n\n表示树形结构。通过回顾上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象的execute方法，程序会递归调用组合对象下面的叶对象的execute方法，所以我们的万能遥控器只需要一次操作，便能依次完成关 门、打开电脑、登录QQ这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。\n利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。\n\n// 创建一个宏命令var MacroCommand = function()&#123;    return &#123;        // 宏命令的子命令列表        commandsList: [],        // 添加命令到子命令列表        add: function( command )&#123;            this.commandsList.push( command );        &#125;,        // 依次执行子命令列表里面的命令        execute: function()&#123;            for ( var i = 0, command; command = this.commandsList[ i++ ]; )&#123;                command.execute();            &#125;        &#125;    &#125;&#125;;&lt;!--打开空调命令--&gt;var openAcCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开空调&#x27; );    &#125;&#125;;&lt;!--打开电视和音响--&gt;var openTvCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开电视&#x27; );    &#125;&#125;;var openSoundCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开音响&#x27; );    &#125;&#125;;//创建一个宏命令var macroCommand1 = MacroCommand();//把打开电视装进这个宏命令里macroCommand1.add(openTvCommand)//把打开音响装进这个宏命令里macroCommand1.add(openSoundCommand)&lt;!--关门、打开电脑和打登录QQ的命令--&gt;var closeDoorCommand = &#123;    execute: function()&#123;        console.log( &#x27;关门&#x27; );    &#125;&#125;;var openPcCommand = &#123;    execute: function()&#123;        console.log( &#x27;开电脑&#x27; );    &#125;&#125;;var openQQCommand = &#123;    execute: function()&#123;        console.log( &#x27;登录QQ&#x27; );    &#125;&#125;;//创建一个宏命令var macroCommand2 = MacroCommand();//把关门命令装进这个宏命令里macroCommand2.add( closeDoorCommand );//把开电脑命令装进这个宏命令里macroCommand2.add( openPcCommand );//把登录QQ命令装进这个宏命令里macroCommand2.add( openQQCommand );&lt;!--把各宏命令装进一个超级命令中去--&gt;var macroCommand = MacroCommand();macroCommand.add( openAcCommand );macroCommand.add( macroCommand1 );macroCommand.add( macroCommand2 );\n\n享元模式\n享元模式的核心是运用共享技术来有效支持大量细粒度的对象，如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用。\n\n享元模式要求对象的属性划分为内部状态和外部状态，如何划分：\n\n内部状态存储于对象内部\n内部状态可以被一些对象共享\n内部状态独立于具体的场景，通常不会变化\n外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。\n\n示例：文件上传\nvar Upload = function(uploadType) &#123;  this.uploadType = uploadType;&#125;​/* 删除文件（内部状态） */Upload.prototype.delFile = function(id) &#123;  uploadManger.setExternalState(id, this);  // 把当前id对应的外部状态都组装到共享对象中  // 大于3000k提示  if(this.fileSize &lt; 3000) &#123;    return this.dom.parentNode.removeChild(this.dom);  &#125;  if(window.confirm(&quot;确定要删除文件吗？&quot; + this.fileName)) &#123;    return this.dom.parentNode.removeChild(this.dom);  &#125;&#125;/** 工厂对象实例化  *  如果某种内部状态的共享对象已经被创建过，那么直接返回这个对象 *  否则，创建一个新的对象 */var UploadFactory = (function() &#123;    var createdFlyWeightObjs = &#123;&#125;;    return &#123;        create: function(uploadType) &#123;            if(createdFlyWeightObjs[ uploadType ]) &#123;                return createdFlyWeightObjs[ uploadType ]            &#125;            return createdFlyWeightObjs[ uploadType ] = new Upload( uploadType );        &#125;    &#125;&#125;)();/* 管理器封装外部状态 */var uploadManger = (function() &#123;  var uploadDatabase = &#123;&#125;;​  return &#123;    add: function(id, uploadType, fileName, fileSize) &#123;      var flyWeightObj = UploadFactory.create(uploadType);      var dom = document.createElement(&#x27;div&#x27;);      dom.innerHTML = &quot;&lt;span&gt;文件名称：&quot; + fileName + &quot;，文件大小：&quot; + fileSize +&quot;&lt;/span&gt;&quot;              + &quot;&lt;button class=&#x27;delFile&#x27;&gt;删除&lt;/button&gt;&quot;;​      dom.querySelector(&quot;.delFile&quot;).onclick = function() &#123;        flyWeightObj.delFile(id);      &#125;;      document.body.appendChild(dom);​      uploadDatabase[id] = &#123;        fileName: fileName,        fileSize: fileSize,        dom: dom      &#125;;​      return flyWeightObj;    &#125;,    setExternalState: function(id, flyWeightObj) &#123;      var uploadData = uploadDatabase[id];      for(var i in uploadData) &#123;        flyWeightObj[i] = uploadData[i];      &#125;    &#125;  &#125;;&#125;)();/*触发上传动作*/var id = 0;window.startUpload = function(uploadType, files) &#123;  for(var i=0,file; file = files[i++];) &#123;    var uploadObj = uploadManger.add(++id, uploadType, file.fileName, file.fileSize);  &#125;&#125;;​/* 测试 */startUpload(&quot;plugin&quot;, [  &#123;    fileName: &#x27;1.txt&#x27;,    fileSize: 1000  &#125;,&#123;    fileName: &#x27;2.txt&#x27;,    fileSize: 3000  &#125;,&#123;    fileName: &#x27;3.txt&#x27;,    fileSize: 5000  &#125;]);startUpload(&quot;flash&quot;, [  &#123;    fileName: &#x27;4.txt&#x27;,    fileSize: 1000  &#125;,&#123;    fileName: &#x27;5.txt&#x27;,    fileSize: 3000  &#125;,&#123;    fileName: &#x27;6.txt&#x27;,    fileSize: 5000  &#125;]);\n\n职责链模式\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n例子：异步职责链的实现\n// Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点var Chain = function ( fn ) &#123;    this.fn = fn;    this.successor = null;&#125;Chain.prototype.setNextSuccessor = function ( successor ) &#123;    return this.successor = successor;&#125;// 对于ret的判断可以用于同步的职责链模式Chain.prototype.passRequest = function () &#123;    var ret = this.fn.apply( this, arguments);    if ( ret === &#x27;nextSuccessor&#x27; ) &#123;        return this.successor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );    &#125;    return ret;&#125;// 异步时ret的return值没有，此时无法接收，因此采用next回调的方式Chain.prototype.next = function () &#123;    return this.nextSuccessor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );&#125;var fn1 = new Chain(function()&#123;    console.log( 1 );    return &#x27;nextSuccessor&#x27;;&#125;);var fn2 = new Chain(function()&#123;    console.log( 2 );    var self = this;    setTimeout(function()&#123;        self.next();    &#125;, 1000 );&#125;);var fn3 = new Chain(function()&#123;    console.log( 3 );&#125;);fn1.setNextSuccessor( fn2 ).setNextSuccessor( fn3 );fn1.passRequest();\n\n用AOP实现职责链\nFunction.prototype.after = function( fn )&#123;    var self = this;    return function()&#123;        var ret = self.apply( this, arguments );        if ( ret === &#x27;nextSuccessor&#x27; )&#123;            return fn.apply( this, arguments );        &#125;        return ret;    &#125;&#125;;// 此处的order500yuan、order200yuan、orderNormal为订单处理的函数，此处未列出var order = order500yuan.after( order200yuan ).after( orderNormal );order( 1, true, 500 ); // 输出：500元定金预购，得到100优惠券order( 2, true, 500 ); // 输出：200元定金预购，得到50优惠券order( 1, false, 500 ); // 输出：普通购买，无优惠券\n\n中介者模式\n中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。\n\n例子：游戏中使用中介者控制游戏状态\n玩家对象的生成：\nfunction Player (name, teamColor) &#123;    this.name = name;    this.teamColor = teamColor;    this.state = &#x27;alive&#x27;;&#125;;Player.prototype.win = function () &#123;    console.log(`$&#123;this.name&#125; won!`);&#125;;Player.prototype.lose = function () &#123;    console.log(`$&#123;this.name&#125; lost!`);&#125;;// 玩家死亡Player.prototype.die = function () &#123;    this.state = &#x27;dead&#x27;;    // 给中介者发送消息，玩家死亡    playerDirector.ReceiveMessage( &#x27;playDead&#x27;, this );&#125;// 移除玩家Player.prototype.remove = function () &#123;    // 给中介者发送消息，玩家移除    playerDirector.ReceiveMessage( &#x27;removePlayer&#x27;, this );&#125;// 玩家换队Player.prototype.remove = function ( color ) &#123;    // 给中介者发送消息，玩家换队    playerDirector.ReceiveMessage( &#x27;changeTeam&#x27;, this, color );&#125;// 生成玩家的工厂函数var palyerFactory = function ( name, teamColor ) &#123;    var newPlayer = new Player( name, teamColor );    // 给中介者发动消息，新增玩家    playerDirecotor.ReceiveMessage( &#x27;addPlayer&#x27;, newPlayer );    return newPlayer;&#125;\n中介者playerDirector的实现：\n\n利用发布—订阅模式。将playerDirector实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirector，playerDirector处理消息后将反馈发送给其他player。\n在playerDirector中开放一些接收消息的接口，各player可以直接调用该接口来给playerDirector发送消息，player只需传递一个参数给playerDirector，这个参数的目的是使playerDirector可以识别发送者。同样，playerDirector接收到消息之后会将处理结果反馈给其他player。\n\n以下采取开发接口的方式：\nvar playerDirector = ( function () &#123;    var players = &#123;&#125;, // 保存所有玩家        operations = &#123;&#125;; // 中介者可以执行的操作    // 新增一个玩家    operations.addPlayer = function ( player ) &#123;        var teamColor = player.teanmColor;        players[ teamColor ] = players[ teamColor ] || [];        players[ teamColor ].push( player );    &#125;    // 移除一个玩家    operations.removePlayer = function ( player ) &#123;        var teamColor = player.teamColor,            teamPlayers = players[ teamColor ] || []        for ( var i = teamPlayers.length - 1; i &gt;= 0; i-- )&#123;   // 遍历删除            if ( teamPlayers[ i ] === player )&#123;                teamPlayers.splice( i, 1 );            &#125;        &#125;    &#125;    // 玩家换队    operations.changeTeam = function ( player, newTeamColor ) &#123;        operations.removePlayer( player );        player.teamColor = newTeamColor;        operations.addPlayer( player );    &#125;    // 玩家死亡    operations.playerDead = function( player )&#123;     // 玩家死亡        var teamColor = player.teamColor,            teamPlayers = players[ teamColor ];   // 玩家所在队伍        var all_dead = true;        for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;            if ( player.state !== &#x27;dead&#x27; )&#123;                all_dead = false;                break;            &#125;        &#125;        if ( all_dead === true )&#123;   // 全部死亡            for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;                player.lose();   // 本队所有玩家lose            &#125;            for ( var color in players )&#123;                if ( color !== teamColor )&#123;                    var teamPlayers = players[ color ];   // 其他队伍的玩家                    for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;                        player.win();   // 其他队伍所有玩家win                    &#125;                &#125;            &#125;        &#125;    &#125;;    // 开发接口    var ReceiveMessage = function () &#123;        // 第一个参数为消息的类型        var message = Array.prototype.shift.call( arguments );        operations[ message ].apply( this, arguments );    &#125;    return &#123;        ReceiveMessage: ReceiveMessage    &#125;&#125;)();\n\n装饰者模式\n装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。\n\n一个简单的例子：\nvar a = function()&#123;    alert (1);&#125;var _a = a;a = function()&#123;    _a();    alert (2);&#125;a();\n\n用AOP装饰函数\nFunction.prototype.before = function ( beforeFn ) &#123;    var _self = this; // 保存原函数的引用    return function () &#123; // 返回包含了原函数和新函数的“代理”函数        beforeFn.apply( this, arguments ); // 执行新函数，保证this不被劫持        return _self.apply( this, arguments ); // 执行原函数并返回原函数的结果，保证this不被劫持    &#125;    &#125;Function.prototype.after = function( afterfn )&#123;    var _self = this;    return function()&#123;        var ret = _self.apply( this, arguments );        afterfn.apply( this, arguments );        return ret;    &#125;&#125;// 使用window.onload = function()&#123;    alert (1);&#125;window.onload = ( window.onload || function()&#123;&#125; ).after(function()&#123;    alert (2);&#125;).after(function()&#123;    alert (3);&#125;).after(function()&#123;    alert (4);&#125;);\n装饰者模式和代理模式\n代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。\n\n状态模式\n定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。\n\n状态模式的通用结构\nvar Light = function()&#123;    // 实例化每一个状态对象    this.offLightState = new OffLightState( this );    // 持有状态对象的引用    this.weakLightState = new WeakLightState( this );    this.strongLightState = new StrongLightState( this );    this.superStrongLightState = new SuperStrongLightState( this );    this.button = null;&#125;;Light.prototype.init = function () &#123;    var button = document.createElement( &#x27;button&#x27; ),        self = this;    this.button = document.body.appendChild( button );    this.button.innerHTML = &#x27;开关&#x27;;    this.currState = this.offLightState; // 设置默认状态    this.button.onclick = function () &#123;        self.currState.buttonWasPressed();    &#125;&#125;// 列举一个状态对象，关灯状态对象var OfflightState = function( light ) &#123;    this.light = light;&#125;OfflightState.prototypr.buttonWasPressed = function () &#123;    console.log(&#x27;弱光&#x27;);    this.light.setState( this.light.weakLightState );&#125;\n\n状态机：使用闭包实现将客户的操作委托给状态对象，此委托需要处理this的劫持\nvar delegate = function ( client, delegation ) &#123;    return &#123;        buttonWasPressed: function () &#123;            return delegation.buttonWasPressed.apply( client, arguments);        &#125;    &#125;&#125;;var FSM = &#123;    off: &#123;        buttonWasPressed: function()&#123;            console.log( &#x27;关灯&#x27; );            this.button.innerHTML = &#x27;下一次按我是开灯&#x27;;            this.currState = this.onState;        &#125;    &#125;,    on: &#123;        buttonWasPressed: function()&#123;            console.log( &#x27;开灯&#x27; );            this.button.innerHTML = &#x27;下一次按我是关灯&#x27;;            this.currState = this.offState;        &#125;    &#125;&#125;;var Light = function () &#123;    this.offState = delegation( this, FSM.off );    this.onState = delegation( this, FSM.on );    this.currState = this.offState;    this.button = null;&#125;Light.prototype.init = function () &#123;    var button = document.createElement( &#x27;button&#x27; );    button.innerHTML = &#x27;已关灯&#x27;;    this.button = document.body.appendChild( button );    this.button.onclick = function () &#123;        self.currState.buttonWasPressed();    &#125;&#125;var light = new Light();light.init();\n\n适配器模式\n适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。实际项目中封装组件时，经常遇到组件定义的接口和后台返回的数据无法完全对应上，这时一个apater函数转化数据是比较方便的选择。\n\n","categories":["前端"],"tags":["javascript"]}]