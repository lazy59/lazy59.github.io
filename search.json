[{"title":"Vue多项目打包","url":"/2022/04/26/Vue%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/","content":"导语有时业务中遇到这样的场景，多个项目有很多共用的逻辑，后面又是独立部署。例如PC端和移动端，UI完全不同，但逻辑有很多能复用，但是这里我们计划是分开部署。这里仅说有这种场景，大致痛点如下。\n\n分两个项目，则代码维护两套，复用逻辑要copy\n合成一个项目：路由区分或者多页配置。这种上线部署的时候又会互相影响，部署则都刷新。且目录在一起，可扒取到另外一个项目的资源。\n\n为此，需要一种方式，能代码共仓以复用逻辑，但是打包部署可以独立。\n实现实现该需求，有如下考虑：\n\n既然可独立打包，那这里考虑打包的时候传参\n多项目在打包配置上可能存在差异，可针对不同项目的灵活配置是必要的\n涉及到部署，那部署的情况也是要考虑到的约定为方便表述，这里做个约定，我们的项目分为mobile、pc两个。\n\n打包传参的处理命令行打包，做以下区分：\n# mobile# 本地运行npm run dev -- --page=mobile# 打包npm run build -- --page=mobile# pc# 本地运行npm run dev -- --page=pc# 打包npm run build -- --page=pc\n以上是参数的传入，接着解析参数，做成通用的，形如 --key=value的都可以被解析。这里我们将参数写成 VUE_APP_PAGE的形式，这样项目代码逻辑中也可以使用这个参数，以便处理复用代码要区分不同项目的场景。同时，这里实现getEnv函数，以便在其他打包逻辑中可以获取到自己想要的参数。\n// 使用正则解析参数function handleEnv() &#123;  const reg = /--(\\w+)=(.+)/;  const keysArr = process.argv.filter( e =&gt; reg.test(e));  keysArr.forEach( varStr =&gt; &#123;    const varArr = varStr.match(reg);    process.env[`VUE_APP_$&#123;varArr[1].toLocaleUpperCase()&#125;`] = varArr[2];  &#125;);&#125;// 获取对应的参数，如果key不传则返回所有的，这里做一次缓存代理，避免重复解析const getEnv = (() =&gt; &#123;  let isHandleEnv = false;  return (key) =&gt; &#123;    if (!isHandleEnv) &#123;      handleEnv();      isHandleEnv = true;    &#125;    return key ? process.env[key] :process.env;  &#125;&#125;)();\n以上已经拿到了参数，接下来是参数用起来\n处理打包配置这里总的逻辑还是使用了pages配置项，不过每次只打包了一个page。首先说明文件，为了方便自定义配置，这里我们拆分文件：\n\ncommon.config.js用来存储多个项目公用的配置\ncustom.config.js用来存储不同项目自定义的配置\nvue.config.js合并common、custom的配置，生成最终的打包配置\n\ncommon.config.js的配置举例如下：\nmodule.exports = &#123;  publicPath: &#x27;./&#x27;,  assetsDir: &#x27;static&#x27;,  productionSourceMap: false,  lintOnSave: true,  devServer: &#123;    host: &#x27;0.0.0.0&#x27;,    port: 3000,    hotOnly: true,     proxy: &#123;      &#x27;/&#x27;: &#123;        ws: true,        target: &#x27;http://test.myproject.com/&#x27;,        changeOrigin: true,        secure: false,      &#125;,    &#125;  &#125;,  configureWebpack: config =&gt; &#123;    // 这里写自定义的webpack配置  &#125;,  chainWebpack(config) &#123;    // 这里我们设置了一下别名    config.resolve.alias      .set(&#x27;@pc&#x27;, resolve(&#x27;./src/pc&#x27;))      .set(&#x27;@mobile&#x27;, resolve(&#x27;./src/mobile&#x27;))      .set(&#x27;@src&#x27;, resolve(&#x27;./src&#x27;))  &#125;&#125;\ncustom.config.js的配置举例如下：\nmodule.exports = &#123;  // 移动端的自定义配置  mobile: &#123;    // page的自定义配置，后面会和默认的配置合并    page: &#123;      title: &#x27;mobile title&#x27;    &#125;  &#125;,  // pc端的自定义配置  pc: &#123;    page: &#123;      title: &#x27;pc title&#x27;    &#125;,    chainWebpack(config) &#123;      // 这里我们设置了一下pc端的svg打包，但是移动端不需要，因此是在自定义配置      config.module      .rule(&#x27;svg&#x27;)      .exclude.add(resolve(&#x27;src/platform/icons&#x27;))      .end()    config.module      .rule(&#x27;icons&#x27;)      .test(/\\.svg$/)      .include.add(resolve(&#x27;src/platform/icons&#x27;))      .end()      .use(&#x27;svg-sprite-loader&#x27;)      .loader(&#x27;svg-sprite-loader&#x27;)      .options(&#123;        symbolId: &#x27;icon-[name]&#x27;      &#125;)      .end()    &#125;  &#125;,&#125;\nvue.config.js的配置，这块是重点，会结合上面两个配置生成最终的配置。\nconst path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);// 导入以上两份配置const commonConfig = require(&#x27;./common.config&#x27;)const customConfig = require(&#x27;./custom.config&#x27;)const &#123; getEnv &#125; = require(&#x27;./utils&#x27;);// 获取到了当前的page参数let pageName = getEnv(&#x27;VUE_APP_PAGE&#x27;);// 我们将pc和mobile两个项目放到了 `src/pages` 目录下const dirs = fs.readdirSync(path.join(__dirname, &#x27;src/pages&#x27;))// 异常处理，当pageName没匹配到时默认做pc处理if (!dirs.includes(pageName)) &#123;  console.warn(`$&#123;pageName&#125; is not exist`);  pageName = &#x27;pc&#x27;;&#125;// 获取对应页面的自定义配置，这里page参数单独拿出作为后面pages配置的合并，其他参数走通用的合并const &#123; page, ...pageCustomConfig &#125; = customConfig[pageName] || &#123; page: &#123;&#125; &#125;;// 根据pageName生成对应的pages配置，这里合并上一步的page参数，目的是当两个项目index.html使用一份的时候，可以不放置两个html，而是使用一个，但是可以通过page参数指定title参数区分const defaultPageConfig = &#123;  pages: &#123;    [pageName]: &#123;      entry: `src/$&#123;pageName&#125;/main.js`,      template: `public/$&#123;pageName&#125;.html`,      filename: &#x27;index.html&#x27;,      ...page    &#125;  &#125;,  // ☆ 这里是关键，打包到dist下面对应项目的子目录，这样可以分开打包两个项目，互不影响  outputDir: `dist/$&#123;pageName&#125;`&#125;// 这里的config就是我们生成的基本配置啦，但是custom的配置还没处理const config = &#123;  ...baseConfig,  ...defaultPageConfig,&#125;// 遍历自定义配置pageCustomConfigfor (const key in pageCustomConfig) &#123;  if (Object.hasOwnProperty.call(pageCustomConfig, key)) &#123;    // 这里拿到的配置有可能是值、也有可能是函数(例如：chainWebpack)    const valueOrFunction = pageCustomConfig[key];    // 当自定义页面配置为函数时，默认会合并自定义配置和baseConfig中的配置。    if (valueOrFunction instanceof Function) &#123;      // 拿到了通用配置中相同项，做函数合并。      const baseFunction = config[key] || function() &#123;&#125;;      config[key] = function() &#123;        // 先调用自定义的配置的函数，如果返回true则代表自定义配置完全覆盖common配置，否则两者合并        const isReplaceBase = valueOrFunction.apply(null, arguments);        // 两者合并的情况，调用common中的配置        !isReplaceBase &amp;&amp; baseFunction.apply(null, arguments);      &#125;    &#125; else &#123;      // 不是函数，则直接覆盖      config[key] = valueOrFunction;    &#125;  &#125;&#125;module.exports = config;\n另外，有些情况可能仅在上面的自定义配置中无法完成，例如这里要修改postcss的配置完成移动端rem的配置，可以修改postcss.config.js\nconst &#123; getEnv &#125; = require(&#x27;./utils&#x27;)const plugins = &#123;  autoprefixer: &#123;&#125;,&#125;// 使用 getEnv 获取当前的page参数，仅在移动端设置rem转化if (getEnv(&#x27;VUE_APP_PAGE&#x27;) === &#x27;mobile&#x27;) &#123;  plugins[&#x27;postcss-pxtorem&#x27;] = &#123;    rootValue: 16,    propList: [&#x27;*&#x27;],    unitPrecision: 5,  &#125;&#125;module.exports = &#123;  plugins&#125;\npackage.json的修改以上就完成了自定义的打包，但是本地运行还要每次传参就比较麻烦，改下package.json让项目更好用。\n&#123;  &quot;scripts&quot;: &#123;    // 默认启动pc    &quot;dev&quot;: &quot;vue-cli-service serve&quot;,    // 启动移动端    &quot;dev:collection&quot;: &quot;npm run dev -- --page=mobile&quot;,    // 默认打包pc    &quot;build&quot;: &quot;vue-cli-service build&quot;,    // 两者一起打包    &quot;build:all&quot;: &quot;npm run build &amp;&amp; npm run build:mobile&quot;,    &quot;build:pc&quot;: &quot;vue-cli-service build&quot;,    // 单独打包移动端    &quot;build:mobile&quot;: &quot;npm run build -- --page=mobile&quot;,  &#125;&#125;\n部署完成以上打包之后，考虑下部署的事情。之前可能部署的方式是直接删除旧的前端包，部署新的。那现在情况不太一样了，pc、mobile都要部署则可以这么干，但是如果只是部署mobile，那之前前端包中的pc就不能删除，这里我们改写下部署的 bash脚本。可能你不是bash脚本，但是原理一样。\n#!/bin/bash# 指定项目目录名称PROJECT_DIR=my-test-project# 指定项目目录放置的地方BASE_DIR=/home/www# 解压比对的临时目录PROJECT_DIR_TEMP=$&#123;BASE_DIR&#125;/$&#123;PROJECT_DIR&#125;-temp# 项目的根目录PROJECT_ROOT_DIR=$&#123;BASE_DIR&#125;/$&#123;PROJECT_DIR&#125;# 处理部署的时候新建项目目录if [ ! -d $&#123;PROJECT_ROOT_DIR&#125; ];thenmkdir -p $&#123;PROJECT_ROOT_DIR&#125;fi# 创建临时目录if [ ! -d $&#123;PROJECT_DIR_TEMP&#125; ];thenmkdir -p $&#123;PROJECT_DIR_TEMP&#125;fi# 拷贝前端包到临时目录，并解压操作cp $&#123;PROJECT_DIR&#125;.zip $&#123;PROJECT_DIR_TEMP&#125;cd $&#123;PROJECT_DIR_TEMP&#125;unzip $&#123;PROJECT_DIR&#125;.ziprm $&#123;PROJECT_DIR&#125;.zip# 此处遍历前端包中的目录，有以下情况# 1. 有pc、mobile两个目录，则是两个项目一块部署，之前两个目录均删除# 2. 仅有一个目录，如仅有mobile目录，则只部署移动端，pc端代码不部署for file in $PROJECT_DIR_TEMP/*doif [ -d &quot;$file&quot; ]then  # 此处读取目录的名称，匹配最后一个 / 之后的名称  page_name=$&#123;file##*/&#125;  echo $page_name  # 如果在项目根目录下存在当前目录，则删除掉该旧目录  if [ -d &quot;$PROJECT_ROOT_DIR/$page_name&quot; ]  then    rm -r &quot;$PROJECT_ROOT_DIR/$page_name&quot;  fifidone# 删除之后将临时目录下解压的文件全部移到项目根目录mv $PROJECT_DIR_TEMP/* $PROJECT_ROOT_DIR# 删除临时目录rm -r $PROJECT_DIR_TEMP\n","categories":["前端"],"tags":["Vue"]},{"title":"hexo使用rsync部署填坑之路","url":"/2021/11/21/hexo%E4%BD%BF%E7%94%A8rsync%E9%83%A8%E7%BD%B2%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/","content":"hexo 可快速上手做出自己的博客网站，部署方式 也非常多。在部署到github的时候基本不会遇到什么问题，但是当选择使用rsync部署到阿里云ECS的时候，windows下部署的坑就一个个的出现了。\n遇到的问题首先看下官方的部署教程， 只有下面一小段内容：\n安装 hexo-deployer-rsync。\n$ npm install hexo-deployer-rsync --save\n修改配置\ndeploy:  type: rsync  host: &lt;host&gt;  user: &lt;user&gt;  root: &lt;root&gt;  port: [port]  delete: [true|false]  verbose: [true|false]  ignore_errors: [true|false]\nrsync不存在的报错直接运行 hexo d 之后就会报错了，有可能在powershell上面是乱码，git bash运行后出现以下报错：\nINFO  Validating configINFO  Deploying: rsync&#x27;rsync&#x27; is not recognized as an internal or external command,operable program or batch file.\n\nwindows默认没安装rsync，查找之后要安装cwrsync。然后去官网下载多个版本后出现了各种其他问题，这里我用5.5.0版本完成了后续操作。\n下载之后进行了如下操作：\n首先，下载的软件包解压到想放的位置，然后双击 cwrsync.cmd 开始安装，正常则会生成 home 目录，但是我这边没有生成(截图中是我后手动添加的)。\n\nok，先没管 home 目录，先将 bin 目录添加到环境变量，以便访问到 rsync.exe 文件。之后再来 hexo d 一次。好，出现了如下报错：\nINFO  Validating configINFO  Deploying: rsyncCould not create directory &#x27;/home/lazy5/.ssh&#x27;.Host key verification failed.rsync: connection unexpectedly closed (0 bytes received so far) [sender]rsync error: error in rsync protocol data stream (code 12) at io.c(226) [sender=3.1.2]\n\n上面报错那意思没找到ssh密钥存储的目录，奇怪的是我这边用户根目录下有.ssh目录，且服务器上也添加了对应公钥。而且这个目录很奇怪，/home这种目录应该指的linux下的目录结构吧。几番研究发现，这个版本的rsync调用的ssh并不是我们安装的，而是cwrsync的bin目录下的ssh.exe，那意思就是这个密钥目录可能不是指向用户目录的，而是cwrsync的安装目录。于是，在安装目录我新建了 /home/lazy5/.ssh 目录。\n同时双击 bin 目录下的 ssh-keygen.exe 文件，之后一路回车，则在 /home/lazy5/.ssh 目录下生成密钥对，目录如下：\n\n将生成的公钥添加到服务器对应用户的 authorized_keys 中，然后再部署一次试试。还是失败了，查看下面的 无权限报错\n无权限报错首先出现的是如下权限过高的问题：\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0770 for &#x27;/home/lazy5/.ssh/id_rsa&#x27; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;/home/lazy5/.ssh/id_rsa&quot;: bad permissionsPermission denied (publickey,gssapi-keyex,gssapi-with-mic).\n\n因此，我删除了 /home/lazy5/.ssh/id_rsa 除了所有者 lazy5 以外的权限。\n以上设置之后，权限过高的问题就没有了。理论上这样部署就没有了，但是在实际操作中还遇到了其他权限问题，具体截图没有了，列举如下：\n\ndeploy 配置使用的是 root ，导致访问被拒绝。这里建议新建一个用户用户rsync的操作，同时建议和本地windows电脑用户名一致，我这里是 lazy5，服务器上也新建了一个一样的用户名。\n部署报建立文件夹没权限的问题：由于新建的 lazy5 不在 root 组，而部署的目录属于 root 用户，chown 将目录权限改到 lazy5， 同时也可以把 lazy5 加到 root 组。\n服务器访问拒绝的其他权限问题：服务器ssh未开启公钥登录的方式，修改配置文件。\nvim /etc/ssh/sshd_config\n增加如下配置： PubkeyAuthentication yesPermitRootLogin yesPasswordAuthentication noRSAAuthentication yes\n重新加载，systemctl restart sshd\n\n\n\n成功上传之后域名访问403一切大功告成，访问网站出现了403，估计是权限的问题了。查看hexo目录下的文件权限如下：\nchmod 777 hexo -R 之后可以正常访问，但是每次部署后都需要登录服务器修改权限，这种方式肯定是不行的。那rsync为什么要改权限呢，依据是什么？前面说到了部署到服务器的文件是lazy5权限，那是不是文件访问的权限是不是也是直接用了本地文件权限。\n查看本地项目目录属性，权限中没有 Everyone，因此添加上去再说。\n重新部署后，终于权限正常了！\n后语以上就是 hexo 中使用 rsync 遇到坑的大致记录，其中由于填坑过程遗漏了很多记录，所以不一定全面，后续有再遇到会继续补充。另外由于坑太多，感觉这里直接 pm2 部署，在服务器上再 hexo generate 生成，估计也能达到一样的效果，后续可尝试并记录下。\n","categories":["服务器"],"tags":["hexo","ssh","部署"]},{"title":"vue-virtual-scroller源码分析","url":"/2021/11/20/vue-virtual-scroller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"该插件目的当页面数据量较大，例如有几千条数据渲染的时候，dom过多产生滚动卡顿的现象。此时使用该插件可以动态渲染可视区的dom，滚动时实时计算和变更可视区显示的数据。\n原理根据可视区的高度以及items中每一项的高度(itemSize，可为高度或者是横向滑动的宽度)来决定页面展示多少个item，能显示的item包装后放到了pool数组中进行渲染，页面滚动的时候动态的修改pool数组。为了在滚动的时候尽可能的减少开销，pool中超出范围的view会回收到复用池，pool中新增的view会优先从复用池中取出view，如果没有复用的才会新增。\n页面中数据流动为了达到动态渲染和dom复用的目的，主要维护了一下三个存放对应item的池子。\n\npool：当前页面显示得视图池，存储当前页面要渲染得数据，即pool是tempalte中渲染真实使用到的。&lt;div    v-for=&quot;view of pool&quot;    :key=&quot;view.nr.id&quot;    :style=&quot;ready ? &#123; transform: `translate$&#123;direction === &#x27;vertical&#x27; ? &#x27;Y&#x27; : &#x27;X&#x27;&#125;($&#123;view.position&#125;px)` &#125; : null&quot;    class=&quot;vue-recycle-scroller__item-view&quot;    :class=&quot;&#123; hover: hoverKey === view.nr.key &#125;&quot;    @mouseenter=&quot;hoverKey = view.nr.key&quot;    @mouseleave=&quot;hoverKey = null&quot;&gt;\n$_views: 和pool对应，每一次addView新增一个视图得时候，除了要把视图放到pool中，还要放一份到views中。只是views是map，数据字典方便查找view，当页面滚动得时候，会取范围在startIndex和endIndex之间得view，每个view先去views中找，这样比在pool中遍历效率要高，如果找到了说明当前view一直在可视区内，这个时候直接显示复用views中得即可。如果在views中没找到，说明是新增得view，则先去复用池中根据type找，找到则复用，找不到则addView新增，新增之后views中也要加进去。\n$_unusedViews: 复用池，根据type存储不在可视区的视图。每次滚动先把超出可视区的丢到unusedViews，丢完之后。进行startIndex和endIndex之间的可视区遍历，在新增view出现的时候优先在unusedViews中找，找到就取出来。找不到则走addView\n\n\n以下是初始化的时候对数据的初始化\n\ncreated () &#123;    // 记录刷新完成的开始索引    this.$_startIndex = 0    // 记录刷新完成的结束索引    this.$_endIndex = 0    // 页面上所有展示的视图，与pool对应，方便快速查找    this.$_views = new Map()    // 复用池：根据视图的type暂存不在使用的view    this.$_unusedViews = new Map()    // 标记是否正在滚动，用于滚动节流    this.$_scrollDirty = false    // 记录上一次滚到了哪里start值    this.$_lastUpdateScrollPosition = 0    // In SSR mode, we also prerender the same number of item for the first render    // to avoir mismatch between server and client templates    if (this.prerender) &#123;      this.$_prerender = true      this.updateVisibleItems(false)    &#125;&#125;,\n\n原理整个插件最主要的原理集中在updateVisibleItems(视图刷新函数)，该函数会在初始化、页面滚动、页面resize等情况下触发。总共的过程分为以下四步：\n\n计算可视范围：获取scroll信息后，先算出此次需要展现到可视区的items索引范围，即startIndex和endIndex。\n\n获取当前展示部分的start、end值, 并判断是否进行了足够的滚动。滚动较小则可视区展示的items不变动，不需要刷新。// 获取当前可视区的范围，getScroll根据scrollerTop等计算const scroll = this.getScroll()// Skip update if use hasn&#x27;t scrolled enough    if (checkPositionDiff) &#123;      // 此处判断当前滚动的范围未超出设置的itemSize，即没有超过一个view，此时pool不需要改变，则此次不进行update操作      let positionDiff = scroll.start - this.$_lastUpdateScrollPosition      if (positionDiff &lt; 0) positionDiff = -positionDiff      if ((itemSize === null &amp;&amp; positionDiff &lt; minItemSize) || positionDiff &lt; itemSize) &#123;        return &#123;          continuous: true,        &#125;      &#125;    &#125;    // 刷新此次滚动后的位置信息    this.$_lastUpdateScrollPosition = scroll.start    // 计算偏移量，默认buffer为200，可自定义    const buffer = this.buffer    scroll.start -= buffer    scroll.end += buffer    // Variable size mode    // 高度可变模式    // 因为每个item的高度不固定，无法直接用scroll.start得到startIndex。所以通过二分法快速查找到第一个出现在可视区的视图，即startIndex。    // 由于计算属性已缓存了可变高度的所有size记录，二分法查找的目的等价于查找到sizes中的索引，该索引满足index项的accumulator小于scroll.start，index+1项的accumulator大于scroll.start，则为刚滑到可视区的startIndex    if (itemSize === null) &#123;      let h      let a = 0      let b = count - 1      // 此处记录二分查找起始点      let i = ~~(count / 2)      let oldI      // Searching for startIndex      do &#123;        oldI = i        h = sizes[i].accumulator        if (h &lt; scroll.start) &#123;          // 说明此次i取小了，则最小值设置为i          a = i        &#125; else if (i &lt; count - 1 &amp;&amp; sizes[i + 1].accumulator &gt; scroll.start) &#123;          // 说明i、i+1都超出了范围，则最大值设置为i，继续查找          b = i        &#125;        // 继续二分        i = ~~((a + b) / 2)      &#125; while (i !== oldI)      i &lt; 0 &amp;&amp; (i = 0)      startIndex = i      // For container style      totalSize = sizes[count - 1].accumulator      // Searching for endIndex      // 找到刚好超出的endIndex      for (endIndex = i; endIndex &lt; count &amp;&amp; sizes[endIndex].accumulator &lt; scroll.end; endIndex++);      if (endIndex === -1) &#123;        endIndex = items.length - 1      &#125; else &#123;        endIndex++        // Bounds        endIndex &gt; count &amp;&amp; (endIndex = count)      &#125;    &#125; else &#123;      // Fixed size mode      // 固定高度：根据滚动的距离计算固定itemSize的startIndex和endIndex      startIndex = ~~(scroll.start / itemSize)      endIndex = Math.ceil(scroll.end / itemSize)      // Bounds      startIndex &lt; 0 &amp;&amp; (startIndex = 0)      endIndex &gt; count &amp;&amp; (endIndex = count)      totalSize = count * itemSize    &#125;  &#125;  if (endIndex - startIndex &gt; config.itemsLimit) &#123;    this.itemsLimitError()  &#125;  // 刷新items的总高度, totalSize会给到外层盒子的高度，为了制造出滚动条  this.totalSize = totalSize\n对于可变高度，计算属性会优先维护一个sizes表，已记录对应索引的size累计值。此操作目的是为了后续根据索引即可拿到size之和，而不必每次都重新计算。sizes () &#123;  // itemSize不提供，则进入variable size mode  if (this.itemSize === null) &#123;    const sizes = &#123;      &#x27;-1&#x27;: &#123; accumulator: 0 &#125;,    &#125;    const items = this.items    const field = this.sizeField    const minItemSize = this.minItemSize    let computedMinSize = 10000    let accumulator = 0    let current    for (let i = 0, l = items.length; i &lt; l; i++) &#123;      current = items[i][field] || minItemSize      if (current &lt; computedMinSize) &#123;        computedMinSize = current      &#125;      accumulator += current      sizes[i] = &#123; accumulator, size: current &#125;    &#125;    // eslint-disable-next-line    this.$_computedMinItemSize = computedMinSize    return sizes  &#125;  return []&#125;\n\n\n视图回收：遍历pool中视图，判断view的索引超出startIndex、endIndex范围，则走到unuseView函数进行视图回收，放到复用池unusedViews。(此时放到复用池只是放的引用，仍指向pool中对应的元素，不会改变pool元素个数，只改对应元素的属性\n\n\nif (this.$_continuous !== continuous) &#123;    if (continuous) &#123;        // 不是连续滑动，则页面出现了大的改变，初始化数据        views.clear()        unusedViews.clear()        for (let i = 0, l = pool.length; i &lt; l; i++) &#123;            // 将当前显示的view回收            view = pool[i]            this.unuseView(view)        &#125;    &#125;    this.$_continuous = continuous&#125; else if (continuous) &#123;    // 此时为连续滑动，遍历回收pool    for (let i = 0, l = pool.length; i &lt; l; i++) &#123;        view = pool[i]        if (view.nr.used) &#123;            // Update view item index            if (checkItem) &#123;                view.nr.index = items.findIndex(                item =&gt; keyField ? item[keyField] === view.item[keyField] : item === view.item,                )            &#125;            // Check if index is still in visible range            // 此处判断如果，index已经超出范围，则进行回收            if (                view.nr.index === -1 ||                view.nr.index &lt; startIndex ||                view.nr.index &gt;= endIndex            ) &#123;                this.unuseView(view)            &#125;        &#125;    &#125;&#125;\n\n以下为unuseView的实现：\nunuseView (view, fake = false) &#123;    // 根据view的类别放到缓存池    const unusedViews = this.$_unusedViews    const type = view.nr.type    // 根据type类别进行存放，后续复用也是根据type去取    let unusedPool = unusedViews.get(type)    if (!unusedPool) &#123;        unusedPool = []        unusedViews.set(type, unusedPool)    &#125;    unusedPool.push(view)    if (!fake) &#123;        // 此时将视图回收设置位置（让view不可见），且used置为false        view.nr.used = false        view.position = -9999        this.$_views.delete(view.nr.key)    &#125;&#125;\n\n\n更新视图：在startIndex和endIndex之间遍历，每次拿到items中的一个item，开始包装item后刷到pool中。\n根据item取views字典中查找，如果找到了，则当前view还在可视区，只是滚动了，则直接复用view即可。\n在views中未找到，则去unusedViews中找有没有可复用的view，有则使用复用视图，修改view的item、key、index等属性后即可。且后面重新设置views中对应字典，方便后面查找。\n如果unusedViews中未找到，则无复用view。此时调用addView新增视图，view增加item属性关联到items、position属性后面用于transform样式、增加used、key、id、index等标识。新增视图push到pool中，同时在views中增加字典。\n\n\n\nlet item, type, unusedPoollet v// 在可视区范围内遍历for (let i = startIndex; i &lt; endIndex; i++) &#123;  item = items[i]  const key = keyField ? item[keyField] : item  if (key == null) &#123;    throw new Error(`Key is $&#123;key&#125; on item (keyField is &#x27;$&#123;keyField&#125;&#x27;)`)  &#125;  // 3.1 根据item取views字典中查找，如果找到了，则当前view还在可视区，只是滚动了，则直接复用view即可。  view = views.get(key)  // 此处size不存在，则高度不存在，则不加到pool，因为显示不出来  if (!itemSize &amp;&amp; !sizes[i].size) &#123;    if (view) this.unuseView(view)    continue  &#125;  // No view assigned to item  // 3.2 在views中未找到，则去unusedViews中找有没有可复用的view，有则使用复用视图，修改view的item、key、index等属性后即可。且后面重新设置views中对应字典，方便后面查找。  if (!view) &#123;    type = item[typeField]    unusedPool = unusedViews.get(type)    if (continuous) &#123;      // Reuse existing view      // 根据类型找出复用池中可用的的视图，修改索引等进行复用      if (unusedPool &amp;&amp; unusedPool.length) &#123;        view = unusedPool.pop()        view.item = item        view.nr.used = true        view.nr.index = i        view.nr.key = key        view.nr.type = type      &#125; else &#123;        // 复用池中不存在则新增        // 3.3 如果unusedViews中未找到，则无复用view。此时调用addView新增视图，view增加item属性关联到items、position属性后面用于transform样式、增加used、key、id、index等标识。新增视图push到pool中，同时在views中增加字典。        view = this.addView(pool, i, item, key, type)      &#125;    &#125; else &#123;      // Use existing view      // We don&#x27;t care if they are already used      // because we are not in continous scrolling      // 因为不是连续滑动，无交叉，不用考虑使用占用的问题，直接从对应复用池中的第一个开始找      v = unusedIndex.get(type) || 0      if (!unusedPool || v &gt;= unusedPool.length) &#123;        view = this.addView(pool, i, item, key, type)        this.unuseView(view, true)        unusedPool = unusedViews.get(type)      &#125;      view = unusedPool[v]      view.item = item      view.nr.used = true      view.nr.index = i      view.nr.key = key      view.nr.type = type      unusedIndex.set(type, v + 1)      v++    &#125;    // 放到views池中，此处对应字典，方便后续查找    views.set(key, view)  &#125; else &#123;    // 当前视图中已经存在，则直接重新used即可    view.nr.used = true    view.item = item  &#125;  // Update position  // 刷新视图位置  if (itemSize === null) &#123;    view.position = sizes[i - 1].accumulator  &#125; else &#123;    view.position = i * itemSize  &#125;&#125;// 记录本地的索引this.$_startIndex = startIndexthis.$_endIndex = endIndex\n\n以下是addView的逻辑，复用池没有的时候走到addView新增视图：\naddView (pool, index, item, key, type) &#123;const view = &#123;  item,  position: 0,&#125;const nonReactive = &#123;  id: uid++,  // 此处的index对应传进来的源数据中的索引，方便后续视图复用后重新排序  index,  used: true,  key,  type,&#125;Object.defineProperty(view, &#x27;nr&#x27;, &#123;  configurable: false,  value: nonReactive,&#125;)// 新增视图放到pool当中pool.push(view)return view&#125;\n\n\n\n排序视图：以上处理完成之后pool可能是无序的，因为存在复用池复用等情况，因此要进行排序，调用sortViews方法会根据pool中视图存的index值进行重排。\n\nclearTimeout(this.$_sortTimer)this.$_sortTimer = setTimeout(this.sortViews, 300)// sortViews的实现sortViews () &#123;  this.pool.sort((viewA, viewB) =&gt; viewA.nr.index - viewB.nr.index)&#125;\n\n结语该插件中pool、$_unusedViews、$_views三者对应的处理是很值得学习的。$_unusedViews的使用使得不比每次都去删减pool的数据达到渲染的目的，反观自己平时的开发，类似滚动、轮播等处理的方式，大概率直接截取源数据的某一范围给到pool达到刷新目的，效果是实现，但是有优化的空间。$_views的使用、以及计算属性sizes的使用均是为了降低复杂度，对于我们动不动就遍历、findIndex等处理，这种预先存储进map、或者预先存储累加值的做法更为优雅，同时也大大的降低了复杂度，减少在每次刷新视图中的遍历逻辑。\n","categories":["前端"],"tags":["Vue"]},{"title":"设计模式","url":"/2021/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"单例模式惰性单例模式封装\nvar getSingle = function (fn) &#123;    var result;    return function () &#123;        return result || ( result = fn.apply(this, arguments) );    &#125;&#125;\n\n策略模式\n定义：定义一系列的算法，把他们一个个封装起来，并使他们可以相互替换。除了算法外，策略模式还可以用来封装一系列的业务规则，例如：表单校验，业务规则可以对应表单校验的规则和错误的提示语。定义好规则策略后，需要校验的地方传入规则名和错误提示即可。\n\n代理模式\n定义：代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。\n\n保护代理：可以增加条件做过滤，拒绝掉一部分的请求，控制不同权限的对象对目标对象的访问虚拟代理：对耗时或者可合并的操作等，做延迟处理，在合适的时机触发。例如：加载图片、合并接口请求等。\n合并请求的虚拟代理例子：\nvar synchromousFile = function ( id ) &#123;    console.log(&#x27;开始同步文件，id为&#x27; + id);&#125;;var proxySynchronousFile = (function () &#123;    var cache = [], // 保存一段时间内需要同步的ID集合    timer;    return function( id ) &#123;        cache.push(id);        if ( timer ) &#123;            return;        &#125;        timer = setTimeout(function() &#123;            synchromousFile( cache.join(&#x27;,&#x27;)); // 2秒后向本体发送需要同步的ID集合            clearTimeout( timer );            timer = null;            cache.length = 0; //清空ID集合        &#125;, 2000)    &#125;&#125;)();\n发布-订阅模式\n定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。优点：一为时间上的解耦，二为对象之间的解耦。缺点：过多的使用会使得模块之间的联系被隐藏到了背后。\n\n以下为全局的发布-订阅对象：\nvar Event = (function () &#123;    var clientList = &#123;&#125;,        listen,        trigger,        remove;        listen = function (key, fn) &#123;        if (!clientList[ key ]) &#123;            clientList[ key ] = [];        &#125;        clientList[ key ].push( fn );    &#125;;    trigger = function () &#123;        var key = Array.prototype.shift.call( arguments ),            fns = clientList[ key ];            if ( !fns || fns.length === 0) &#123;                return false;            &#125;            for ( var i = 0, fn; fn = fns[ i++ ]; ) &#123;                fn.apply( this, arguments);            &#125;    &#125;    remove = function ( key, fn ) &#123;        var fns = clientList[ key ];        if ( !fns ) &#123;            return false;        &#125;        if ( !fn ) &#123;            fns &amp;&amp; ( fns.length = 0);        &#125; else &#123;            for ( var l = fns.length - 1; l &gt;= 0; l--) &#123;                var _fn = fns[ l ];                if ( _fn === fn ) &#123;                    fns.splice( l, 1);                &#125;            &#125;        &#125;    &#125;;    return &#123;        listen: listen,        trigger: trigger,        remove: remove    &#125;&#125;)();\n\n命令模式\n定义：指的是一个执行某些特定事情的指令。最常用的场景：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。命令模式支持撤销、排队、宏命令等。\n\n使用闭包的命令模式：\nvar setCommand = function ( button, func ) &#123;    button.onclick = function () &#123;        func();    &#125;&#125;;var MenuBar = &#123;    refresh: function () &#123;        console.log( &#x27;刷新&#x27; );    &#125;&#125;;var RefreshMenuBarCommand = function ( receiver ) &#123;    return function () &#123;        receiver.refresh();    &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar );setCommand( button1, refreshMenuBarCommand);\n\n组合模式组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明。\n\n表示树形结构。通过回顾上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象的execute方法，程序会递归调用组合对象下面的叶对象的execute方法，所以我们的万能遥控器只需要一次操作，便能依次完成关 门、打开电脑、登录QQ这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。\n利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。\n\n// 创建一个宏命令var MacroCommand = function()&#123;    return &#123;        // 宏命令的子命令列表        commandsList: [],        // 添加命令到子命令列表        add: function( command )&#123;            this.commandsList.push( command );        &#125;,        // 依次执行子命令列表里面的命令        execute: function()&#123;            for ( var i = 0, command; command = this.commandsList[ i++ ]; )&#123;                command.execute();            &#125;        &#125;    &#125;&#125;;&lt;!--打开空调命令--&gt;var openAcCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开空调&#x27; );    &#125;&#125;;&lt;!--打开电视和音响--&gt;var openTvCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开电视&#x27; );    &#125;&#125;;var openSoundCommand = &#123;    execute: function()&#123;        console.log( &#x27;打开音响&#x27; );    &#125;&#125;;//创建一个宏命令var macroCommand1 = MacroCommand();//把打开电视装进这个宏命令里macroCommand1.add(openTvCommand)//把打开音响装进这个宏命令里macroCommand1.add(openSoundCommand)&lt;!--关门、打开电脑和打登录QQ的命令--&gt;var closeDoorCommand = &#123;    execute: function()&#123;        console.log( &#x27;关门&#x27; );    &#125;&#125;;var openPcCommand = &#123;    execute: function()&#123;        console.log( &#x27;开电脑&#x27; );    &#125;&#125;;var openQQCommand = &#123;    execute: function()&#123;        console.log( &#x27;登录QQ&#x27; );    &#125;&#125;;//创建一个宏命令var macroCommand2 = MacroCommand();//把关门命令装进这个宏命令里macroCommand2.add( closeDoorCommand );//把开电脑命令装进这个宏命令里macroCommand2.add( openPcCommand );//把登录QQ命令装进这个宏命令里macroCommand2.add( openQQCommand );&lt;!--把各宏命令装进一个超级命令中去--&gt;var macroCommand = MacroCommand();macroCommand.add( openAcCommand );macroCommand.add( macroCommand1 );macroCommand.add( macroCommand2 );\n\n享元模式\n享元模式的核心是运用共享技术来有效支持大量细粒度的对象，如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用。\n\n享元模式要求对象的属性划分为内部状态和外部状态，如何划分：\n\n内部状态存储于对象内部\n内部状态可以被一些对象共享\n内部状态独立于具体的场景，通常不会变化\n外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。\n\n示例：文件上传\nvar Upload = function(uploadType) &#123;  this.uploadType = uploadType;&#125;​/* 删除文件（内部状态） */Upload.prototype.delFile = function(id) &#123;  uploadManger.setExternalState(id, this);  // 把当前id对应的外部状态都组装到共享对象中  // 大于3000k提示  if(this.fileSize &lt; 3000) &#123;    return this.dom.parentNode.removeChild(this.dom);  &#125;  if(window.confirm(&quot;确定要删除文件吗？&quot; + this.fileName)) &#123;    return this.dom.parentNode.removeChild(this.dom);  &#125;&#125;/** 工厂对象实例化  *  如果某种内部状态的共享对象已经被创建过，那么直接返回这个对象 *  否则，创建一个新的对象 */var UploadFactory = (function() &#123;    var createdFlyWeightObjs = &#123;&#125;;    return &#123;        create: function(uploadType) &#123;            if(createdFlyWeightObjs[ uploadType ]) &#123;                return createdFlyWeightObjs[ uploadType ]            &#125;            return createdFlyWeightObjs[ uploadType ] = new Upload( uploadType );        &#125;    &#125;&#125;)();/* 管理器封装外部状态 */var uploadManger = (function() &#123;  var uploadDatabase = &#123;&#125;;​  return &#123;    add: function(id, uploadType, fileName, fileSize) &#123;      var flyWeightObj = UploadFactory.create(uploadType);      var dom = document.createElement(&#x27;div&#x27;);      dom.innerHTML = &quot;&lt;span&gt;文件名称：&quot; + fileName + &quot;，文件大小：&quot; + fileSize +&quot;&lt;/span&gt;&quot;              + &quot;&lt;button class=&#x27;delFile&#x27;&gt;删除&lt;/button&gt;&quot;;​      dom.querySelector(&quot;.delFile&quot;).onclick = function() &#123;        flyWeightObj.delFile(id);      &#125;;      document.body.appendChild(dom);​      uploadDatabase[id] = &#123;        fileName: fileName,        fileSize: fileSize,        dom: dom      &#125;;​      return flyWeightObj;    &#125;,    setExternalState: function(id, flyWeightObj) &#123;      var uploadData = uploadDatabase[id];      for(var i in uploadData) &#123;        flyWeightObj[i] = uploadData[i];      &#125;    &#125;  &#125;;&#125;)();/*触发上传动作*/var id = 0;window.startUpload = function(uploadType, files) &#123;  for(var i=0,file; file = files[i++];) &#123;    var uploadObj = uploadManger.add(++id, uploadType, file.fileName, file.fileSize);  &#125;&#125;;​/* 测试 */startUpload(&quot;plugin&quot;, [  &#123;    fileName: &#x27;1.txt&#x27;,    fileSize: 1000  &#125;,&#123;    fileName: &#x27;2.txt&#x27;,    fileSize: 3000  &#125;,&#123;    fileName: &#x27;3.txt&#x27;,    fileSize: 5000  &#125;]);startUpload(&quot;flash&quot;, [  &#123;    fileName: &#x27;4.txt&#x27;,    fileSize: 1000  &#125;,&#123;    fileName: &#x27;5.txt&#x27;,    fileSize: 3000  &#125;,&#123;    fileName: &#x27;6.txt&#x27;,    fileSize: 5000  &#125;]);\n\n职责链模式\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n例子：异步职责链的实现\n// Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点var Chain = function ( fn ) &#123;    this.fn = fn;    this.successor = null;&#125;Chain.prototype.setNextSuccessor = function ( successor ) &#123;    return this.successor = successor;&#125;// 对于ret的判断可以用于同步的职责链模式Chain.prototype.passRequest = function () &#123;    var ret = this.fn.apply( this, arguments);    if ( ret === &#x27;nextSuccessor&#x27; ) &#123;        return this.successor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );    &#125;    return ret;&#125;// 异步时ret的return值没有，此时无法接收，因此采用next回调的方式Chain.prototype.next = function () &#123;    return this.nextSuccessor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );&#125;var fn1 = new Chain(function()&#123;    console.log( 1 );    return &#x27;nextSuccessor&#x27;;&#125;);var fn2 = new Chain(function()&#123;    console.log( 2 );    var self = this;    setTimeout(function()&#123;        self.next();    &#125;, 1000 );&#125;);var fn3 = new Chain(function()&#123;    console.log( 3 );&#125;);fn1.setNextSuccessor( fn2 ).setNextSuccessor( fn3 );fn1.passRequest();\n\n用AOP实现职责链\nFunction.prototype.after = function( fn )&#123;    var self = this;    return function()&#123;        var ret = self.apply( this, arguments );        if ( ret === &#x27;nextSuccessor&#x27; )&#123;            return fn.apply( this, arguments );        &#125;        return ret;    &#125;&#125;;// 此处的order500yuan、order200yuan、orderNormal为订单处理的函数，此处未列出var order = order500yuan.after( order200yuan ).after( orderNormal );order( 1, true, 500 ); // 输出：500元定金预购，得到100优惠券order( 2, true, 500 ); // 输出：200元定金预购，得到50优惠券order( 1, false, 500 ); // 输出：普通购买，无优惠券\n\n中介者模式\n中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。\n\n例子：游戏中使用中介者控制游戏状态\n玩家对象的生成：\nfunction Player (name, teamColor) &#123;    this.name = name;    this.teamColor = teamColor;    this.state = &#x27;alive&#x27;;&#125;;Player.prototype.win = function () &#123;    console.log(`$&#123;this.name&#125; won!`);&#125;;Player.prototype.lose = function () &#123;    console.log(`$&#123;this.name&#125; lost!`);&#125;;// 玩家死亡Player.prototype.die = function () &#123;    this.state = &#x27;dead&#x27;;    // 给中介者发送消息，玩家死亡    playerDirector.ReceiveMessage( &#x27;playDead&#x27;, this );&#125;// 移除玩家Player.prototype.remove = function () &#123;    // 给中介者发送消息，玩家移除    playerDirector.ReceiveMessage( &#x27;removePlayer&#x27;, this );&#125;// 玩家换队Player.prototype.remove = function ( color ) &#123;    // 给中介者发送消息，玩家换队    playerDirector.ReceiveMessage( &#x27;changeTeam&#x27;, this, color );&#125;// 生成玩家的工厂函数var palyerFactory = function ( name, teamColor ) &#123;    var newPlayer = new Player( name, teamColor );    // 给中介者发动消息，新增玩家    playerDirecotor.ReceiveMessage( &#x27;addPlayer&#x27;, newPlayer );    return newPlayer;&#125;\n中介者playerDirector的实现：\n\n利用发布—订阅模式。将playerDirector实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirector，playerDirector处理消息后将反馈发送给其他player。\n在playerDirector中开放一些接收消息的接口，各player可以直接调用该接口来给playerDirector发送消息，player只需传递一个参数给playerDirector，这个参数的目的是使playerDirector可以识别发送者。同样，playerDirector接收到消息之后会将处理结果反馈给其他player。\n\n以下采取开发接口的方式：\nvar playerDirector = ( function () &#123;    var players = &#123;&#125;, // 保存所有玩家        operations = &#123;&#125;; // 中介者可以执行的操作    // 新增一个玩家    operations.addPlayer = function ( player ) &#123;        var teamColor = player.teanmColor;        players[ teamColor ] = players[ teamColor ] || [];        players[ teamColor ].push( player );    &#125;    // 移除一个玩家    operations.removePlayer = function ( player ) &#123;        var teamColor = player.teamColor,            teamPlayers = players[ teamColor ] || []        for ( var i = teamPlayers.length - 1; i &gt;= 0; i-- )&#123;   // 遍历删除            if ( teamPlayers[ i ] === player )&#123;                teamPlayers.splice( i, 1 );            &#125;        &#125;    &#125;    // 玩家换队    operations.changeTeam = function ( player, newTeamColor ) &#123;        operations.removePlayer( player );        player.teamColor = newTeamColor;        operations.addPlayer( player );    &#125;    // 玩家死亡    operations.playerDead = function( player )&#123;     // 玩家死亡        var teamColor = player.teamColor,            teamPlayers = players[ teamColor ];   // 玩家所在队伍        var all_dead = true;        for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;            if ( player.state !== &#x27;dead&#x27; )&#123;                all_dead = false;                break;            &#125;        &#125;        if ( all_dead === true )&#123;   // 全部死亡            for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;                player.lose();   // 本队所有玩家lose            &#125;            for ( var color in players )&#123;                if ( color !== teamColor )&#123;                    var teamPlayers = players[ color ];   // 其他队伍的玩家                    for ( var i = 0, player; player = teamPlayers[ i++ ]; )&#123;                        player.win();   // 其他队伍所有玩家win                    &#125;                &#125;            &#125;        &#125;    &#125;;    // 开发接口    var ReceiveMessage = function () &#123;        // 第一个参数为消息的类型        var message = Array.prototype.shift.call( arguments );        operations[ message ].apply( this, arguments );    &#125;    return &#123;        ReceiveMessage: ReceiveMessage    &#125;&#125;)();\n\n装饰者模式\n装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。\n\n一个简单的例子：\nvar a = function()&#123;    alert (1);&#125;var _a = a;a = function()&#123;    _a();    alert (2);&#125;a();\n\n用AOP装饰函数\nFunction.prototype.before = function ( beforeFn ) &#123;    var _self = this; // 保存原函数的引用    return function () &#123; // 返回包含了原函数和新函数的“代理”函数        beforeFn.apply( this, arguments ); // 执行新函数，保证this不被劫持        return _self.apply( this, arguments ); // 执行原函数并返回原函数的结果，保证this不被劫持    &#125;    &#125;Function.prototype.after = function( afterfn )&#123;    var _self = this;    return function()&#123;        var ret = _self.apply( this, arguments );        afterfn.apply( this, arguments );        return ret;    &#125;&#125;// 使用window.onload = function()&#123;    alert (1);&#125;window.onload = ( window.onload || function()&#123;&#125; ).after(function()&#123;    alert (2);&#125;).after(function()&#123;    alert (3);&#125;).after(function()&#123;    alert (4);&#125;);\n装饰者模式和代理模式\n代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。\n\n状态模式\n定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。\n\n状态模式的通用结构\nvar Light = function()&#123;    // 实例化每一个状态对象    this.offLightState = new OffLightState( this );    // 持有状态对象的引用    this.weakLightState = new WeakLightState( this );    this.strongLightState = new StrongLightState( this );    this.superStrongLightState = new SuperStrongLightState( this );    this.button = null;&#125;;Light.prototype.init = function () &#123;    var button = document.createElement( &#x27;button&#x27; ),        self = this;    this.button = document.body.appendChild( button );    this.button.innerHTML = &#x27;开关&#x27;;    this.currState = this.offLightState; // 设置默认状态    this.button.onclick = function () &#123;        self.currState.buttonWasPressed();    &#125;&#125;// 列举一个状态对象，关灯状态对象var OfflightState = function( light ) &#123;    this.light = light;&#125;OfflightState.prototypr.buttonWasPressed = function () &#123;    console.log(&#x27;弱光&#x27;);    this.light.setState( this.light.weakLightState );&#125;\n\n状态机：使用闭包实现将客户的操作委托给状态对象，此委托需要处理this的劫持\nvar delegate = function ( client, delegation ) &#123;    return &#123;        buttonWasPressed: function () &#123;            return delegation.buttonWasPressed.apply( client, arguments);        &#125;    &#125;&#125;;var FSM = &#123;    off: &#123;        buttonWasPressed: function()&#123;            console.log( &#x27;关灯&#x27; );            this.button.innerHTML = &#x27;下一次按我是开灯&#x27;;            this.currState = this.onState;        &#125;    &#125;,    on: &#123;        buttonWasPressed: function()&#123;            console.log( &#x27;开灯&#x27; );            this.button.innerHTML = &#x27;下一次按我是关灯&#x27;;            this.currState = this.offState;        &#125;    &#125;&#125;;var Light = function () &#123;    this.offState = delegation( this, FSM.off );    this.onState = delegation( this, FSM.on );    this.currState = this.offState;    this.button = null;&#125;Light.prototype.init = function () &#123;    var button = document.createElement( &#x27;button&#x27; );    button.innerHTML = &#x27;已关灯&#x27;;    this.button = document.body.appendChild( button );    this.button.onclick = function () &#123;        self.currState.buttonWasPressed();    &#125;&#125;var light = new Light();light.init();\n\n适配器模式\n适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。实际项目中封装组件时，经常遇到组件定义的接口和后台返回的数据无法完全对应上，这时一个apater函数转化数据是比较方便的选择。\n\n","categories":["前端"],"tags":["javascript"]}]